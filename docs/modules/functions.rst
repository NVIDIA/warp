..
   Autogenerated File - Do not edit. Run build_docs.py to generate.

.. functions:
.. currentmodule:: warp

Kernel Reference
================

Scalar Types
------------
.. class:: int8
.. class:: uint8
.. class:: int16
.. class:: uint16
.. class:: int32
.. class:: uint32
.. class:: int64
.. class:: uint64
.. class:: float16
.. class:: float32
.. class:: float64
.. class:: bool


Vector Types
------------
.. class:: vec2b
.. class:: vec2ub
.. class:: vec2s
.. class:: vec2us
.. class:: vec2i
.. class:: vec2ui
.. class:: vec2l
.. class:: vec2ul
.. class:: vec2h
.. class:: vec2f
.. class:: vec2d
.. class:: vec3b
.. class:: vec3ub
.. class:: vec3s
.. class:: vec3us
.. class:: vec3i
.. class:: vec3ui
.. class:: vec3l
.. class:: vec3ul
.. class:: vec3h
.. class:: vec3f
.. class:: vec3d
.. class:: vec4b
.. class:: vec4ub
.. class:: vec4s
.. class:: vec4us
.. class:: vec4i
.. class:: vec4ui
.. class:: vec4l
.. class:: vec4ul
.. class:: vec4h
.. class:: vec4f
.. class:: vec4d
.. class:: mat22h
.. class:: mat22f
.. class:: mat22d
.. class:: mat33h
.. class:: mat33f
.. class:: mat33d
.. class:: mat44h
.. class:: mat44f
.. class:: mat44d
.. class:: quath
.. class:: quatf
.. class:: quatd
.. class:: transformh
.. class:: transformf
.. class:: transformd
.. class:: spatial_vectorh
.. class:: spatial_vectorf
.. class:: spatial_vectord
.. class:: spatial_matrixh
.. class:: spatial_matrixf
.. class:: spatial_matrixd

Generic Types
-------------
.. class:: Int
.. class:: Float
.. class:: Scalar
.. class:: Vector
.. class:: Matrix
.. class:: Quaternion
.. class:: Transformation
.. class:: Array

Query Types
-------------
.. autoclass:: bvh_query_t
.. autoclass:: hash_grid_query_t
.. autoclass:: mesh_query_aabb_t
.. autoclass:: mesh_query_point_t
.. autoclass:: mesh_query_ray_t


Scalar Math
---------------
.. py:function:: min(x: Scalar, y: Scalar) -> Scalar

    Return the minimum of two scalars.


.. py:function:: min(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    Return the element-wise minimum of two vectors.


.. py:function:: min(v: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    Return the minimum element of a vector ``v``.


.. py:function:: max(x: Scalar, y: Scalar) -> Scalar

    Return the maximum of two scalars.


.. py:function:: max(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    Return the element-wise maximum of two vectors.


.. py:function:: max(v: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    Return the maximum element of a vector ``v``.


.. py:function:: clamp(x: Scalar, a: Scalar, b: Scalar) -> Scalar

    Clamp the value of ``x`` to the range [a, b].


.. py:function:: abs(x: Scalar) -> Scalar

    Return the absolute value of ``x``.


.. py:function:: abs(a: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    Return the absolute values of the elements of ``a``.


.. py:function:: sign(x: Scalar) -> Scalar

    Return -1 if ``x`` < 0, return 1 otherwise.


.. py:function:: sign(a: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    Return -1 for the negative elements of ``a``, and 1 otherwise.


.. py:function:: step(x: Scalar) -> Scalar

    Return 1.0 if ``x`` < 0.0, return 0.0 otherwise.


.. py:function:: nonzero(x: Scalar) -> Scalar

    Return 1.0 if ``x`` is not equal to zero, return 0.0 otherwise.


.. py:function:: sin(x: Float) -> Float

    Return the sine of ``x`` in radians.


.. py:function:: cos(x: Float) -> Float

    Return the cosine of ``x`` in radians.


.. py:function:: acos(x: Float) -> Float

    Return arccos of ``x`` in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. py:function:: asin(x: Float) -> Float

    Return arcsin of ``x`` in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. py:function:: sqrt(x: Float) -> Float

    Return the square root of ``x``, where ``x`` is positive.


.. py:function:: cbrt(x: Float) -> Float

    Return the cube root of ``x``.


.. py:function:: tan(x: Float) -> Float

    Return the tangent of ``x`` in radians.


.. py:function:: atan(x: Float) -> Float

    Return the arctangent of ``x`` in radians.


.. py:function:: atan2(y: Float, x: Float) -> Float

    Return the 2-argument arctangent, atan2, of the point ``(x, y)`` in radians.


.. py:function:: sinh(x: Float) -> Float

    Return the sinh of ``x``.


.. py:function:: cosh(x: Float) -> Float

    Return the cosh of ``x``.


.. py:function:: tanh(x: Float) -> Float

    Return the tanh of ``x``.


.. py:function:: degrees(x: Float) -> Float

    Convert ``x`` from radians into degrees.


.. py:function:: radians(x: Float) -> Float

    Convert ``x`` from degrees into radians.


.. py:function:: log(x: Float) -> Float

    Return the natural logarithm (base-e) of ``x``, where ``x`` is positive.


.. py:function:: log2(x: Float) -> Float

    Return the binary logarithm (base-2) of ``x``, where ``x`` is positive.


.. py:function:: log10(x: Float) -> Float

    Return the common logarithm (base-10) of ``x``, where ``x`` is positive.


.. py:function:: exp(x: Float) -> Float

    Return the value of the exponential function :math:`e^x`.


.. py:function:: pow(x: Float, y: Float) -> Float

    Return the result of ``x`` raised to power of ``y``.


.. py:function:: round(x: Float) -> Float

    Return the nearest integer value to ``x``, rounding halfway cases away from zero.

    This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like :func:`warp.rint()`.
    Differs from :func:`numpy.round()`, which behaves the same way as :func:`numpy.rint()`.


.. py:function:: rint(x: Float) -> Float

    Return the nearest integer value to ``x``, rounding halfway cases to nearest even integer.

    It is generally faster than :func:`warp.round()`. Equivalent to :func:`numpy.rint()`.


.. py:function:: trunc(x: Float) -> Float

    Return the nearest integer that is closer to zero than ``x``.

    In other words, it discards the fractional part of ``x``.
    It is similar to casting ``float(int(x))``, but preserves the negative sign when x is in the range [-0.0, -1.0).
    Equivalent to :func:`numpy.trunc()` and :func:`numpy.fix()`.


.. py:function:: floor(x: Float) -> Float

    Return the largest integer that is less than or equal to ``x``.


.. py:function:: ceil(x: Float) -> Float

    Return the smallest integer that is greater than or equal to ``x``.


.. py:function:: frac(x: Float) -> Float

    Retrieve the fractional part of x.

    In other words, it discards the integer part of x and is equivalent to ``x - trunc(x)``.


.. py:function:: isfinite(x: Scalar) -> bool

    Return ``True`` if x is a finite number, otherwise return ``False``.


.. py:function:: isfinite(x: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if all elements of the vector ``x`` are finite, otherwise return ``False``.


.. py:function:: isfinite(x: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if all elements of the quaternion ``x`` are finite, otherwise return ``False``.


.. py:function:: isfinite(m: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if all elements of the matrix ``m`` are finite, otherwise return ``False``.


.. py:function:: isnan(x: Scalar) -> bool

    Return ``True`` if ``x`` is NaN, otherwise return ``False``.


.. py:function:: isnan(x: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the vector ``x`` is NaN, otherwise return ``False``.


.. py:function:: isnan(x: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the quaternion ``x`` is NaN, otherwise return ``False``.


.. py:function:: isnan(m: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the matrix ``m`` is NaN, otherwise return ``False``.


.. py:function:: isinf(x: Scalar) -> bool

    Return ``True`` if x is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(x: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the vector ``x`` is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(x: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the quaternion ``x`` is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(m: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    Return ``True`` if any element of the matrix ``m`` is positive or negative infinity, otherwise return ``False``.




Vector Math
---------------
.. py:function:: dot(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Scalar

    Compute the dot product between two vectors.


.. py:function:: dot(x: Quaternion[Float], y: Quaternion[Float]) -> Float
    :noindex:
    :nocontentsentry:

    Compute the dot product between two quaternions.


.. py:function:: ddot(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Scalar

    Compute the double dot product between two matrices.


.. py:function:: argmin(v: Vector[Any,Scalar]) -> uint32

    Return the index of the minimum element of a vector ``v``. [1]_


.. py:function:: argmax(v: Vector[Any,Scalar]) -> uint32

    Return the index of the maximum element of a vector ``v``. [1]_


.. py:function:: outer(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    Compute the outer product ``x*y^T`` for two vectors.


.. py:function:: cross(x: Vector[3,Scalar], y: Vector[3,Scalar]) -> Vector[3,Scalar]

    Compute the cross product of two 3D vectors.


.. py:function:: skew(x: Vector[3,Scalar])

    Compute the skew-symmetric 3x3 matrix for a 3D vector ``x``.


.. py:function:: length(x: Vector[Any,Float]) -> Float

    Compute the length of a floating-point vector ``x``.


.. py:function:: length(x: Quaternion[Float]) -> Float
    :noindex:
    :nocontentsentry:

    Compute the length of a quaternion ``x``.


.. py:function:: length_sq(x: Vector[Any,Scalar]) -> Scalar

    Compute the squared length of a vector ``x``.


.. py:function:: length_sq(x: Quaternion[Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    Compute the squared length of a quaternion ``x``.


.. py:function:: normalize(x: Vector[Any,Float]) -> Vector[Any,Float]

    Compute the normalized value of ``x``. If ``length(x)`` is 0 then the zero vector is returned.


.. py:function:: normalize(x: Quaternion[Float]) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    Compute the normalized value of ``x``. If ``length(x)`` is 0, then the zero quaternion is returned.


.. py:function:: transpose(m: Matrix[Any,Any,Scalar])

    Return the transpose of the matrix ``m``.


.. py:function:: inverse(m: Matrix[2,2,Float]) -> Matrix[Any,Any,Float]

    Return the inverse of a 2x2 matrix ``m``.


.. py:function:: inverse(m: Matrix[3,3,Float]) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    Return the inverse of a 3x3 matrix ``m``.


.. py:function:: inverse(m: Matrix[4,4,Float]) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    Return the inverse of a 4x4 matrix ``m``.


.. py:function:: determinant(m: Matrix[2,2,Float]) -> Float

    Return the determinant of a 2x2 matrix ``m``.


.. py:function:: determinant(m: Matrix[3,3,Float]) -> Float
    :noindex:
    :nocontentsentry:

    Return the determinant of a 3x3 matrix ``m``.


.. py:function:: determinant(m: Matrix[4,4,Float]) -> Float
    :noindex:
    :nocontentsentry:

    Return the determinant of a 4x4 matrix ``m``.


.. py:function:: trace(m: Matrix[Any,Any,Scalar]) -> Scalar

    Return the trace of the matrix ``m``.


.. py:function:: diag(d: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    Returns a matrix with the components of the vector ``d`` on the diagonal.


.. py:function:: get_diag(m: Matrix[Any,Any,Scalar]) -> Vector[Any,Scalar]

    Returns a vector containing the diagonal elements of the square matrix ``m``.


.. py:function:: cw_mul(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]

    Component-wise multiplication of two vectors.


.. py:function:: cw_mul(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    Component-wise multiplication of two matrices.


.. py:function:: cw_div(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]

    Component-wise division of two vectors.


.. py:function:: cw_div(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    Component-wise division of two matrices.


.. py:function:: vector(*args: Scalar, length: int32, dtype: Scalar) -> Vector[Any,Scalar]

    Construct a vector of given length and dtype.


.. py:function:: matrix(pos: Vector[3,Float], rot: Quaternion[Float], scale: Vector[3,Float], dtype: Float) -> Matrix[4,4,Float]

    Construct a 4x4 transformation matrix that applies the transformations as
    Translation(pos)*Rotation(rot)*Scale(scale) when applied to column vectors, i.e.: y = (TRS)*x


.. py:function:: matrix(*args: Scalar, shape: Tuple[int, int], dtype: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    Construct a matrix. If the positional ``arg_types`` are not given, then matrix will be zero-initialized.


.. py:function:: identity(n: int32, dtype: Scalar) -> Matrix[Any,Any,Scalar]

    Create an identity matrix with shape=(n,n) with the type given by ``dtype``.


.. py:function:: svd3(A: Matrix[3,3,Float], U: Matrix[3,3,Float], sigma: Vector[3,Float], V: Matrix[3,3,Scalar]) -> None

    Compute the SVD of a 3x3 matrix ``A``. The singular values are returned in ``sigma``,
    while the left and right basis vectors are returned in ``U`` and ``V``.


.. py:function:: qr3(A: Matrix[3,3,Float], Q: Matrix[3,3,Float], R: Matrix[3,3,Float]) -> None

    Compute the QR decomposition of a 3x3 matrix ``A``. The orthogonal matrix is returned in ``Q``,
    while the upper triangular matrix is returned in ``R``.


.. py:function:: eig3(A: Matrix[3,3,Float], Q: Matrix[3,3,Float], d: Vector[3,Float]) -> None

    Compute the eigendecomposition of a 3x3 matrix ``A``. The eigenvectors are returned as the columns of ``Q``,
    while the corresponding eigenvalues are returned in ``d``.




Quaternion Math
---------------
.. py:function:: quaternion(dtype: Float) -> Quaternion[Float]

    Construct a zero-initialized quaternion. Quaternions are laid out as
    [ix, iy, iz, r], where ix, iy, iz are the imaginary part, and r the real part.


.. py:function:: quaternion(x: Float, y: Float, z: Float, w: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    Create a quaternion using the supplied components (type inferred from component type).


.. py:function:: quaternion(i: Vector[3,Float], r: Float, dtype: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    Create a quaternion using the supplied vector/scalar (type inferred from scalar type).


.. py:function:: quaternion(q: Quaternion[Float], dtype: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    Construct a quaternion of type dtype from another quaternion of a different dtype.


.. py:function:: quat_identity(dtype: Float) -> quatf

    Construct an identity quaternion with zero imaginary part and real part of 1.0


.. py:function:: quat_from_axis_angle(axis: Vector[3,Float], angle: Float) -> Quaternion[Float]

    Construct a quaternion representing a rotation of angle radians around the given axis.


.. py:function:: quat_to_axis_angle(q: Quaternion[Float], axis: Vector[3,Float], angle: Float) -> None

    Extract the rotation axis and angle radians a quaternion represents.


.. py:function:: quat_from_matrix(m: Matrix[3,3,Float]) -> Quaternion[Float]

    Construct a quaternion from a 3x3 matrix.


.. py:function:: quat_rpy(roll: Float, pitch: Float, yaw: Float) -> Quaternion[Float]

    Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. py:function:: quat_inverse(q: Quaternion[Float]) -> Quaternion[Float]

    Compute quaternion conjugate.


.. py:function:: quat_rotate(q: Quaternion[Float], p: Vector[3,Float]) -> Vector[3,Float]

    Rotate a vector by a quaternion.


.. py:function:: quat_rotate_inv(q: Quaternion[Float], p: Vector[3,Float]) -> Vector[3,Float]

    Rotate a vector by the inverse of a quaternion.


.. py:function:: quat_slerp(q0: Quaternion[Float], q1: Quaternion[Float], t: Float) -> Quaternion[Float]

    Linearly interpolate between two quaternions.


.. py:function:: quat_to_matrix(q: Quaternion[Float]) -> Matrix[3,3,Float]

    Convert a quaternion to a 3x3 rotation matrix.




Transformations
---------------
.. py:function:: transformation(p: Vector[3,Float], q: Quaternion[Float], dtype: Float) -> Transformation[Float]

    Construct a rigid-body transformation with translation part ``p`` and rotation ``q``.


.. py:function:: transform_identity(dtype: Float) -> transformf

    Construct an identity transform with zero translation and identity rotation.


.. py:function:: transform_get_translation(t: Transformation[Float]) -> Vector[3,Float]

    Return the translational part of a transform ``t``.


.. py:function:: transform_get_rotation(t: Transformation[Float]) -> Quaternion[Float]

    Return the rotational part of a transform ``t``.


.. py:function:: transform_multiply(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]

    Multiply two rigid body transformations together.


.. py:function:: transform_point(t: Transformation[Float], p: Vector[3,Float]) -> Vector[3,Float]

    Apply the transform to a point ``p`` treating the homogeneous coordinate as w=1 (translation and rotation).


.. py:function:: transform_point(m: Matrix[4,4,Float], p: Vector[3,Float]) -> Vector[3,Float]
    :noindex:
    :nocontentsentry:

    Apply the transform to a point ``p`` treating the homogeneous coordinate as w=1.

    The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``.
    Note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.


.. py:function:: transform_vector(t: Transformation[Float], v: Vector[3,Float]) -> Vector[3,Float]

    Apply the transform to a vector ``v`` treating the homogeneous coordinate as w=0 (rotation only).


.. py:function:: transform_vector(m: Matrix[4,4,Float], v: Vector[3,Float]) -> Vector[3,Float]
    :noindex:
    :nocontentsentry:

    Apply the transform to a vector ``v`` treating the homogeneous coordinate as w=0.

    The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
    note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.


.. py:function:: transform_inverse(t: Transformation[Float]) -> Transformation[Float]

    Compute the inverse of the transformation ``t``.




Spatial Math
---------------
.. py:function:: spatial_vector(dtype: Float)

    Zero-initialize a 6D screw vector.


.. py:function:: spatial_vector(w: Vector[3,Float], v: Vector[3,Float], dtype: Float)
    :noindex:
    :nocontentsentry:

    Construct a 6D screw vector from two 3D vectors.


.. py:function:: spatial_vector(wx: Float, wy: Float, wz: Float, vx: Float, vy: Float, vz: Float, dtype: Float)
    :noindex:
    :nocontentsentry:

    Construct a 6D screw vector from six values.


.. py:function:: spatial_adjoint(r: Matrix[3,3,Float], s: Matrix[3,3,Float]) -> Matrix[6,6,Float]

    Construct a 6x6 spatial inertial matrix from two 3x3 diagonal blocks.


.. py:function:: spatial_dot(a: Vector[6,Float], b: Vector[6,Float]) -> Float

    Compute the dot product of two 6D screw vectors.


.. py:function:: spatial_cross(a: Vector[6,Float], b: Vector[6,Float]) -> Vector[6,Float]

    Compute the cross product of two 6D screw vectors.


.. py:function:: spatial_cross_dual(a: Vector[6,Float], b: Vector[6,Float]) -> Vector[6,Float]

    Compute the dual cross product of two 6D screw vectors.


.. py:function:: spatial_top(a: Vector[6,Float])

    Return the top (first) part of a 6D screw vector.


.. py:function:: spatial_bottom(a: Vector[6,Float])

    Return the bottom (second) part of a 6D screw vector.


.. py:function:: spatial_jacobian(S: Array[Vector[6,Float]], joint_parents: Array[int32], joint_qd_start: Array[int32], joint_start: int32, joint_count: int32, J_start: int32, J_out: Array[Float]) -> None


.. py:function:: spatial_mass(I_s: Array[Matrix[6,6,Float]], joint_start: int32, joint_count: int32, M_start: int32, M: Array[Float]) -> None




Utility
---------------
.. py:function:: mlp(weights: Array[float32], bias: Array[float32], activation: Callable, index: int32, x: Array[float32], out: Array[float32]) -> None

    Evaluate a multi-layer perceptron (MLP) layer in the form: ``out = act(weights*x + bias)``.

    :param weights: A layer's network weights with dimensions ``(m, n)``.
    :param bias: An array with dimensions ``(n)``.
    :param activation: A ``wp.func`` function that takes a single scalar float as input and returns a scalar float as output
    :param index: The batch item to process, typically each thread will process one item in the batch, in which case
                  index should be ``wp.tid()``
    :param x: The feature matrix with dimensions ``(n, b)``
    :param out: The network output with dimensions ``(m, b)``

    :note: Feature and output matrices are transposed compared to some other frameworks such as PyTorch.
           All matrices are assumed to be stored in flattened row-major memory layout (NumPy default).


.. py:function:: printf(fmt: str, *args: Any) -> None

    Allows printing formatted strings using C-style format specifiers.


.. py:function:: print(value: Any) -> None

    Print variable to stdout


.. py:function:: breakpoint() -> None

    Debugger breakpoint


.. py:function:: tid() -> int

    Return the current thread index for a 1D kernel launch.

    Note that this is the *global* index of the thread in the range [0, dim)
    where dim is the parameter passed to kernel launch.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int]
    :noindex:
    :nocontentsentry:

    Return the current thread indices for a 2D kernel launch.

    Use ``i,j = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int, int]
    :noindex:
    :nocontentsentry:

    Return the current thread indices for a 3D kernel launch.

    Use ``i,j,k = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int, int, int]
    :noindex:
    :nocontentsentry:

    Return the current thread indices for a 4D kernel launch.

    Use ``i,j,k,l = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: select(cond: bool, arg1: Any, arg2: Any)

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: int8, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: uint8, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: int16, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: uint16, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: int32, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: uint32, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: int64, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(cond: uint64, arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``cond`` is ``False`` then return ``arg1``, otherwise return ``arg2``


.. py:function:: select(arr: Array[Any], arg1: Any, arg2: Any)
    :noindex:
    :nocontentsentry:

    Select between two arguments, if ``arr`` is null then return ``arg1``, otherwise return ``arg2``


.. py:function:: atomic_add(arr: Array[Any], i: int32, value: Any)

    Atomically add ``value`` onto ``arr[i]``.


.. py:function:: atomic_add(arr: Array[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_add(arr: Array[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_add(arr: Array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i]``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i]``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically add ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_sub(arr: Array[Any], i: int32, value: Any)

    Atomically subtract ``value`` onto ``arr[i]``.


.. py:function:: atomic_sub(arr: Array[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_sub(arr: Array[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_sub(arr: Array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i]``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i]``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j]``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k]``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Atomically subtract ``value`` onto ``arr[i,j,k,l]``.


.. py:function:: atomic_min(arr: Array[Any], i: int32, value: Any)

    Compute the minimum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the minimum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: int32, value: Any)

    Compute the maximum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: int32, j: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: int32, j: int32, k: int32, l: int32, value: Any)
    :noindex:
    :nocontentsentry:

    Compute the maximum of ``value`` and ``arr[i,j,k,l]`` and atomically update the array.

    .. note:: The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: lerp(a: Float, b: Float, t: Float) -> Float

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Vector[Any,Float], b: Vector[Any,Float], t: Float) -> Vector[Any,Float]
    :noindex:
    :nocontentsentry:

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Matrix[Any,Any,Float], b: Matrix[Any,Any,Float], t: Float) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Quaternion[Float], b: Quaternion[Float], t: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Transformation[Float], b: Transformation[Float], t: Float) -> Transformation[Float]
    :noindex:
    :nocontentsentry:

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: smoothstep(edge0: Float, edge1: Float, x: Float) -> Float

    Smoothly interpolate between two values ``edge0`` and ``edge1`` using a factor ``x``,
    and return a result between 0 and 1 using a cubic Hermite interpolation after clamping.


.. py:function:: expect_near(arg1: Float, arg2: Float, tolerance: Float) -> None

    Prints an error to stdout if ``arg1`` and ``arg2`` are not closer than tolerance in magnitude


.. py:function:: expect_near(arg1: vec3f, arg2: vec3f, tolerance: float32) -> None
    :noindex:
    :nocontentsentry:

    Prints an error to stdout if any element of ``arg1`` and ``arg2`` are not closer than tolerance in magnitude




Geometry
---------------
.. py:function:: bvh_query_aabb(id: uint64, lower: vec3f, upper: vec3f) -> bvh_query_t

    Construct an axis-aligned bounding box query against a BVH object.

    This query can be used to iterate over all bounds inside a BVH.

    :param id: The BVH identifier
    :param lower: The lower bound of the bounding box in BVH space
    :param upper: The upper bound of the bounding box in BVH space


.. py:function:: bvh_query_ray(id: uint64, start: vec3f, dir: vec3f) -> bvh_query_t

    Construct a ray query against a BVH object.

    This query can be used to iterate over all bounds that intersect the ray.

    :param id: The BVH identifier
    :param start: The start of the ray in BVH space
    :param dir: The direction of the ray in BVH space


.. py:function:: bvh_query_next(query: bvh_query_t, index: int32) -> bool

    Move to the next bound returned by the query.
    The index of the current bound is stored in ``index``, returns ``False`` if there are no more overlapping bound.


.. py:function:: mesh_query_point(id: uint64, point: vec3f, max_dist: float32) -> mesh_query_point_t

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance using additional ray-casts to determine if the point is inside or outside.
    This method is relatively robust, but does increase computational cost.
    See below for additional sign determination methods.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query


.. py:function:: mesh_query_point_no_sign(id: uint64, point: vec3f, max_dist: float32) -> mesh_query_point_t

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    This method does not compute the sign of the point (inside/outside) which makes it faster than other point query methods.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query


.. py:function:: mesh_query_furthest_point_no_sign(id: uint64, point: vec3f, min_dist: float32) -> mesh_query_point_t

    Computes the furthest point on the mesh with identifier `id` to the given point in space.

    This method does not compute the sign of the point (inside/outside).

    :param id: The mesh identifier
    :param point: The point in space to query
    :param min_dist: Mesh faces below this distance will not be considered by the query


.. py:function:: mesh_query_point_sign_normal(id: uint64, point: vec3f, max_dist: float32, epsilon: float32) -> mesh_query_point_t

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance (inside/outside) using the angle-weighted pseudo normal.
    This approach to sign determination is robust for well conditioned meshes that are watertight and non-self intersecting.
    It is also comparatively fast to compute.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query
    :param epsilon: Epsilon treating distance values as equal, when locating the minimum distance vertex/face/edge, as a
                    fraction of the average edge length, also for treating closest point as being on edge/vertex default 1e-3


.. py:function:: mesh_query_point_sign_winding_number(id: uint64, point: vec3f, max_dist: float32, accuracy: float32, threshold: float32) -> mesh_query_point_t

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given point in space.

    Identifies the sign using the winding number of the mesh relative to the query point. This method of sign determination is robust for poorly conditioned meshes
    and provides a smooth approximation to sign even when the mesh is not watertight. This method is the most robust and accurate of the sign determination meshes
    but also the most expensive.

    .. note:: The :class:`Mesh` object must be constructed with ``support_winding_number=True`` for this method to return correct results.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query
    :param accuracy: Accuracy for computing the winding number with fast winding number method utilizing second-order dipole approximation, default 2.0
    :param threshold: The threshold of the winding number to be considered inside, default 0.5


.. py:function:: mesh_query_ray(id: uint64, start: vec3f, dir: vec3f, max_t: float32) -> mesh_query_ray_t

    Computes the closest ray hit on the :class:`Mesh` with identifier ``id``.

    :param id: The mesh identifier
    :param start: The start point of the ray
    :param dir: The ray direction (should be normalized)
    :param max_t: The maximum distance along the ray to check for intersections


.. py:function:: mesh_query_aabb(id: uint64, lower: vec3f, upper: vec3f) -> mesh_query_aabb_t

    Construct an axis-aligned bounding box query against a :class:`Mesh`.

    This query can be used to iterate over all triangles inside a volume.

    :param id: The mesh identifier
    :param lower: The lower bound of the bounding box in mesh space
    :param upper: The upper bound of the bounding box in mesh space


.. py:function:: mesh_query_aabb_next(query: mesh_query_aabb_t, index: int32) -> bool

    Move to the next triangle overlapping the query bounding box.

    The index of the current face is stored in ``index``, returns ``False`` if there are no more overlapping triangles.


.. py:function:: mesh_eval_position(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f

    Evaluates the position on the :class:`Mesh` given a face index and barycentric coordinates.


.. py:function:: mesh_eval_velocity(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f

    Evaluates the velocity on the :class:`Mesh` given a face index and barycentric coordinates.


.. py:function:: hash_grid_query(id: uint64, point: vec3f, max_dist: float32) -> hash_grid_query_t

    Construct a point query against a :class:`HashGrid`.

    This query can be used to iterate over all neighboring point within a fixed radius from the query point.


.. py:function:: hash_grid_query_next(query: hash_grid_query_t, index: int32) -> bool

    Move to the next point in the hash grid query.

    The index of the current neighbor is stored in ``index``, returns ``False`` if there are no more neighbors.


.. py:function:: hash_grid_point_id(id: uint64, index: int32) -> int

    Return the index of a point in the :class:`HashGrid`.

    This can be used to reorder threads such that grid traversal occurs in a spatially coherent order.

    Returns -1 if the :class:`HashGrid` has not been reserved.


.. py:function:: intersect_tri_tri(v0: vec3f, v1: vec3f, v2: vec3f, u0: vec3f, u1: vec3f, u2: vec3f) -> int

    Tests for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Moller's method.

    Returns > 0 if triangles intersect.


.. py:function:: mesh_get(id: uint64) -> Mesh

    Retrieves the mesh given its index. [1]_


.. py:function:: mesh_eval_face_normal(id: uint64, face: int32) -> vec3f

    Evaluates the face normal the mesh given a face index.


.. py:function:: mesh_get_point(id: uint64, index: int32) -> vec3f

    Returns the point of the mesh given a index.


.. py:function:: mesh_get_velocity(id: uint64, index: int32) -> vec3f

    Returns the velocity of the mesh given a index.


.. py:function:: mesh_get_index(id: uint64, index: int32) -> int

    Returns the point-index of the mesh given a face-vertex index.


.. py:function:: closest_point_edge_edge(p1: vec3f, q1: vec3f, p2: vec3f, q2: vec3f, epsilon: float32) -> vec3f

    Finds the closest points between two edges.

    Returns barycentric weights to the points on each edge, as well as the closest distance between the edges.

    :param p1: First point of first edge
    :param q1: Second point of first edge
    :param p2: First point of second edge
    :param q2: Second point of second edge
    :param epsilon: Zero tolerance for determining if points in an edge are degenerate.
    :param out: vec3 output containing (s,t,d), where `s` in [0,1] is the barycentric weight for the first edge, `t` is the barycentric weight for the second edge, and `d` is the distance between the two edges at these two closest points.




Volumes
---------------
.. py:function:: volume_sample(id: uint64, uvw: vec3f, sampling_mode: int32, dtype: Any) -> Any

    Sample the volume of type `dtype` given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_sample_grad(id: uint64, uvw: vec3f, sampling_mode: int32, grad: Any, dtype: Any) -> Any

    Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup(id: uint64, i: int32, j: int32, k: int32, dtype: Any) -> Any

    Returns the value of voxel with coordinates ``i``, ``j``, ``k`` for a volume of type type `dtype`.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store(id: uint64, i: int32, j: int32, k: int32, value: Any) -> None

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_f(id: uint64, uvw: vec3f, sampling_mode: int32) -> float

    Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_sample_grad_f(id: uint64, uvw: vec3f, sampling_mode: int32, grad: vec3f) -> float

    Sample the volume and its gradient given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup_f(id: uint64, i: int32, j: int32, k: int32) -> float

    Returns the value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value


.. py:function:: volume_store_f(id: uint64, i: int32, j: int32, k: int32, value: float32) -> None

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_v(id: uint64, uvw: vec3f, sampling_mode: int32) -> vec3f

    Sample the vector volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup_v(id: uint64, i: int32, j: int32, k: int32) -> vec3f

    Returns the vector value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store_v(id: uint64, i: int32, j: int32, k: int32, value: vec3f) -> None

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_i(id: uint64, uvw: vec3f) -> int

    Sample the :class:`int32` volume given by ``id`` at the volume local-space point ``uvw``. 


.. py:function:: volume_lookup_i(id: uint64, i: int32, j: int32, k: int32) -> int

    Returns the :class:`int32` value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store_i(id: uint64, i: int32, j: int32, k: int32, value: int32) -> None

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_index(id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any) -> Any

    Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and `background` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.
    


.. py:function:: volume_sample_grad_index(id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any, grad: Any) -> Any

    Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and `background` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.
   


.. py:function:: volume_lookup_index(id: uint64, i: int32, j: int32, k: int32) -> int32

    Returns the index associated to the voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns -1.
    This function is available for both index grids and classical volumes.
    


.. py:function:: volume_index_to_world(id: uint64, uvw: vec3f) -> vec3f

    Transform a point ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation.


.. py:function:: volume_world_to_index(id: uint64, xyz: vec3f) -> vec3f

    Transform a point ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation.


.. py:function:: volume_index_to_world_dir(id: uint64, uvw: vec3f) -> vec3f

    Transform a direction ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation.


.. py:function:: volume_world_to_index_dir(id: uint64, xyz: vec3f) -> vec3f

    Transform a direction ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation.




Random
---------------
.. py:function:: rand_init(seed: int32) -> uint32

    Initialize a new random number generator given a user-defined seed. Returns a 32-bit integer representing the RNG state.


.. py:function:: rand_init(seed: int32, offset: int32) -> uint32
    :noindex:
    :nocontentsentry:

    Initialize a new random number generator given a user-defined seed and an offset.

    This alternative constructor can be useful in parallel programs, where a kernel as a whole should share a seed,
    but each thread should generate uncorrelated values. In this case usage should be ``r = rand_init(seed, tid)``


.. py:function:: randi(state: uint32) -> int

    Return a random integer in the range [0, 2^32).


.. py:function:: randi(state: uint32, min: int32, max: int32) -> int
    :noindex:
    :nocontentsentry:

    Return a random integer between [min, max).


.. py:function:: randf(state: uint32) -> float

    Return a random float between [0.0, 1.0).


.. py:function:: randf(state: uint32, min: float32, max: float32) -> float
    :noindex:
    :nocontentsentry:

    Return a random float between [min, max).


.. py:function:: randn(state: uint32) -> float

    Sample a normal distribution.


.. py:function:: sample_cdf(state: uint32, cdf: Array[float32]) -> int

    Inverse-transform sample a cumulative distribution function.


.. py:function:: sample_triangle(state: uint32) -> vec2f

    Uniformly sample a triangle. Returns sample barycentric coordinates.


.. py:function:: sample_unit_ring(state: uint32) -> vec2f

    Uniformly sample a ring in the xy plane.


.. py:function:: sample_unit_disk(state: uint32) -> vec2f

    Uniformly sample a disk in the xy plane.


.. py:function:: sample_unit_sphere_surface(state: uint32) -> vec3f

    Uniformly sample a unit sphere surface.


.. py:function:: sample_unit_sphere(state: uint32) -> vec3f

    Uniformly sample a unit sphere.


.. py:function:: sample_unit_hemisphere_surface(state: uint32) -> vec3f

    Uniformly sample a unit hemisphere surface.


.. py:function:: sample_unit_hemisphere(state: uint32) -> vec3f

    Uniformly sample a unit hemisphere.


.. py:function:: sample_unit_square(state: uint32) -> vec2f

    Uniformly sample a unit square.


.. py:function:: sample_unit_cube(state: uint32) -> vec3f

    Uniformly sample a unit cube.


.. py:function:: poisson(state: uint32, lam: float32) -> uint32

    Generate a random sample from a Poisson distribution.

    :param state: RNG state
    :param lam: The expected value of the distribution


.. py:function:: noise(state: uint32, x: float32) -> float

    Non-periodic Perlin-style noise in 1D.


.. py:function:: noise(state: uint32, xy: vec2f) -> float
    :noindex:
    :nocontentsentry:

    Non-periodic Perlin-style noise in 2D.


.. py:function:: noise(state: uint32, xyz: vec3f) -> float
    :noindex:
    :nocontentsentry:

    Non-periodic Perlin-style noise in 3D.


.. py:function:: noise(state: uint32, xyzt: vec4f) -> float
    :noindex:
    :nocontentsentry:

    Non-periodic Perlin-style noise in 4D.


.. py:function:: pnoise(state: uint32, x: float32, px: int32) -> float

    Periodic Perlin-style noise in 1D.


.. py:function:: pnoise(state: uint32, xy: vec2f, px: int32, py: int32) -> float
    :noindex:
    :nocontentsentry:

    Periodic Perlin-style noise in 2D.


.. py:function:: pnoise(state: uint32, xyz: vec3f, px: int32, py: int32, pz: int32) -> float
    :noindex:
    :nocontentsentry:

    Periodic Perlin-style noise in 3D.


.. py:function:: pnoise(state: uint32, xyzt: vec4f, px: int32, py: int32, pz: int32, pt: int32) -> float
    :noindex:
    :nocontentsentry:

    Periodic Perlin-style noise in 4D.


.. py:function:: curlnoise(state: uint32, xy: vec2f, octaves: uint32, lacunarity: float32, gain: float32) -> vec2f

    Divergence-free vector field based on the gradient of a Perlin noise function. [1]_


.. py:function:: curlnoise(state: uint32, xyz: vec3f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f
    :noindex:
    :nocontentsentry:

    Divergence-free vector field based on the curl of three Perlin noise functions. [1]_


.. py:function:: curlnoise(state: uint32, xyzt: vec4f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f
    :noindex:
    :nocontentsentry:

    Divergence-free vector field based on the curl of three Perlin noise functions. [1]_




Other
---------------
.. py:function:: lower_bound(arr: Array[Scalar], value: Scalar) -> int

    Search a sorted array ``arr`` for the closest element greater than or equal to ``value``.


.. py:function:: lower_bound(arr: Array[Scalar], arr_begin: int32, arr_end: int32, value: Scalar) -> int
    :noindex:
    :nocontentsentry:

    Search a sorted array ``arr`` in the range [arr_begin, arr_end) for the closest element greater than or equal to ``value``.


.. py:function:: bit_and(x: Int, y: Int) -> Int


.. py:function:: bit_or(x: Int, y: Int) -> Int


.. py:function:: bit_xor(x: Int, y: Int) -> Int


.. py:function:: lshift(x: Int, y: Int) -> Int


.. py:function:: rshift(x: Int, y: Int) -> Int


.. py:function:: invert(x: Int) -> Int




Operators
---------------
.. py:function:: add(x: Scalar, y: Scalar) -> Scalar


.. py:function:: add(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: add(x: Quaternion[Scalar], y: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: add(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: add(x: Transformation[Scalar], y: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: sub(x: Scalar, y: Scalar) -> Scalar


.. py:function:: sub(x: Vector[Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: sub(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: sub(x: Quaternion[Scalar], y: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: sub(x: Transformation[Scalar], y: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Scalar, y: Scalar) -> Scalar


.. py:function:: mul(x: Vector[Any,Scalar], y: Scalar) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Scalar, y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Quaternion[Scalar], y: Scalar) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Scalar, y: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Quaternion[Scalar], y: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Scalar, y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Matrix[Any,Any,Scalar], y: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Matrix[Any,Any,Scalar], y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Vector[Any,Scalar], y: Matrix[Any,Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Matrix[Any,Any,Scalar], y: Matrix[Any,Any,Scalar])
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Transformation[Scalar], y: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Scalar, y: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mul(x: Transformation[Scalar], y: Scalar) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: mod(x: Scalar, y: Scalar) -> Scalar


.. py:function:: div(x: Scalar, y: Scalar) -> Scalar


.. py:function:: div(x: Vector[Any,Scalar], y: Scalar) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: div(x: Scalar, y: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: div(x: Matrix[Any,Any,Scalar], y: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: div(x: Scalar, y: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: div(x: Quaternion[Scalar], y: Scalar) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: div(x: Scalar, y: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: floordiv(x: Scalar, y: Scalar) -> Scalar


.. py:function:: pos(x: Scalar) -> Scalar


.. py:function:: pos(x: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: pos(x: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: pos(x: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: neg(x: Scalar) -> Scalar


.. py:function:: neg(x: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: neg(x: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: neg(x: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: bool) -> bool


.. py:function:: unot(b: int8) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: uint8) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: int16) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: uint16) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: int32) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: uint32) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: int64) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(b: uint64) -> bool
    :noindex:
    :nocontentsentry:


.. py:function:: unot(a: Array[Any]) -> bool
    :noindex:
    :nocontentsentry:


.. rubric:: Footnotes
.. [1] Function gradients have not been implemented for backpropagation.
