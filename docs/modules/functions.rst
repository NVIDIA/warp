..
   Autogenerated File - Do not edit. Run build_docs.py to generate.

.. functions:
.. currentmodule:: warp

Built-Ins Reference
===================
This section lists the Warp types and functions available to use from Warp kernels and optionally also from the Warp Python runtime API.
For a listing of the API that is exclusively intended to be used at the *Python Scope* and run inside the CPython interpreter, see the :doc:`runtime` section.


Scalar Types
------------
.. class:: int8
.. class:: uint8
.. class:: int16
.. class:: uint16
.. class:: int32
.. class:: uint32
.. class:: int64
.. class:: uint64
.. class:: float16
.. class:: float32
.. class:: float64
.. class:: bool


Vector Types
------------
.. class:: vec2b
.. class:: vec2ub
.. class:: vec2s
.. class:: vec2us
.. class:: vec2i
.. class:: vec2ui
.. class:: vec2l
.. class:: vec2ul
.. class:: vec2h
.. class:: vec2f
.. class:: vec2d
.. class:: vec3b
.. class:: vec3ub
.. class:: vec3s
.. class:: vec3us
.. class:: vec3i
.. class:: vec3ui
.. class:: vec3l
.. class:: vec3ul
.. class:: vec3h
.. class:: vec3f
.. class:: vec3d
.. class:: vec4b
.. class:: vec4ub
.. class:: vec4s
.. class:: vec4us
.. class:: vec4i
.. class:: vec4ui
.. class:: vec4l
.. class:: vec4ul
.. class:: vec4h
.. class:: vec4f
.. class:: vec4d
.. class:: mat22h
.. class:: mat22f
.. class:: mat22d
.. class:: mat33h
.. class:: mat33f
.. class:: mat33d
.. class:: mat44h
.. class:: mat44f
.. class:: mat44d
.. class:: quath
.. class:: quatf
.. class:: quatd
.. class:: transformh
.. class:: transformf
.. class:: transformd
.. class:: spatial_vectorh
.. class:: spatial_vectorf
.. class:: spatial_vectord
.. class:: spatial_matrixh
.. class:: spatial_matrixf
.. class:: spatial_matrixd

Generic Types
-------------
.. class:: Int
.. class:: Float
.. class:: Scalar
.. class:: Vector
.. class:: Matrix
.. class:: Quaternion
.. class:: Transformation
.. class:: Array


Scalar Math
---------------
.. py:function:: min(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the minimum of two scalars.


.. py:function:: min(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the element-wise minimum of two vectors.


.. py:function:: min(a: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the minimum element of a vector ``a``.


.. py:function:: max(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the maximum of two scalars.


.. py:function:: max(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the element-wise maximum of two vectors.


.. py:function:: max(a: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the maximum element of a vector ``a``.


.. py:function:: clamp(x: Scalar, low: Scalar, high: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Clamp the value of ``x`` to the range [low, high].


.. py:function:: abs(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the absolute value of ``x``.


.. py:function:: abs(x: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the absolute values of the elements of ``x``.


.. py:function:: sign(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return -1 if ``x`` < 0, return 1 otherwise.


.. py:function:: sign(x: Vector[Any,Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return -1 for the negative elements of ``x``, and 1 otherwise.


.. py:function:: step(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return 1.0 if ``x`` < 0.0, return 0.0 otherwise.


.. py:function:: nonzero(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return 1.0 if ``x`` is not equal to zero, return 0.0 otherwise.


.. py:function:: sin(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the sine of ``x`` in radians.


.. py:function:: cos(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the cosine of ``x`` in radians.


.. py:function:: acos(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return arccos of ``x`` in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. py:function:: asin(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return arcsin of ``x`` in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. py:function:: sqrt(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the square root of ``x``, where ``x`` is positive.


.. py:function:: cbrt(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the cube root of ``x``.


.. py:function:: tan(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the tangent of ``x`` in radians.


.. py:function:: atan(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the arctangent of ``x`` in radians.


.. py:function:: atan2(y: Float, x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the 2-argument arctangent, atan2, of the point ``(x, y)`` in radians.


.. py:function:: sinh(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the sinh of ``x``.


.. py:function:: cosh(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the cosh of ``x``.


.. py:function:: tanh(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the tanh of ``x``.


.. py:function:: degrees(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Convert ``x`` from radians into degrees.


.. py:function:: radians(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Convert ``x`` from degrees into radians.


.. py:function:: log(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the natural logarithm (base-e) of ``x``, where ``x`` is positive.


.. py:function:: log2(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the binary logarithm (base-2) of ``x``, where ``x`` is positive.


.. py:function:: log10(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the common logarithm (base-10) of ``x``, where ``x`` is positive.


.. py:function:: exp(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the value of the exponential function :math:`e^x`.


.. py:function:: pow(x: Float, y: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the result of ``x`` raised to power of ``y``.


.. py:function:: erf(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the error function of ``x``.


.. py:function:: erfc(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the complementary error function of ``x``.


.. py:function:: erfinv(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the inverse error function of ``x``.


.. py:function:: erfcinv(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the inverse complementary error function of ``x``.


.. py:function:: round(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the nearest integer value to ``x``, rounding halfway cases away from zero.

    This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like :func:`warp.rint()`.
    Differs from :func:`numpy.round()`, which behaves the same way as :func:`numpy.rint()`.


.. py:function:: rint(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the nearest integer value to ``x``, rounding halfway cases to nearest even integer.

    It is generally faster than :func:`warp.round()`. Equivalent to :func:`numpy.rint()`.


.. py:function:: trunc(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the nearest integer that is closer to zero than ``x``.

    In other words, it discards the fractional part of ``x``.
    It is similar to casting ``float(int(a))``, but preserves the negative sign when ``x`` is in the range [-0.0, -1.0).
    Equivalent to :func:`numpy.trunc()` and :func:`numpy.fix()`.


.. py:function:: floor(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the largest integer that is less than or equal to ``x``.


.. py:function:: ceil(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the smallest integer that is greater than or equal to ``x``.


.. py:function:: frac(x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Retrieve the fractional part of ``x``.

    In other words, it discards the integer part of ``x`` and is equivalent to ``x - trunc(x)``.


.. py:function:: isfinite(a: Scalar) -> bool

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if ``a`` is a finite number, otherwise return ``False``.


.. py:function:: isfinite(a: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if all elements of the vector ``a`` are finite, otherwise return ``False``.


.. py:function:: isfinite(a: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if all elements of the quaternion ``a`` are finite, otherwise return ``False``.


.. py:function:: isfinite(a: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if all elements of the matrix ``a`` are finite, otherwise return ``False``.


.. py:function:: isnan(a: Scalar) -> bool

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if ``a`` is NaN, otherwise return ``False``.


.. py:function:: isnan(a: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the vector ``a`` is NaN, otherwise return ``False``.


.. py:function:: isnan(a: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the quaternion ``a`` is NaN, otherwise return ``False``.


.. py:function:: isnan(a: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the matrix ``a`` is NaN, otherwise return ``False``.


.. py:function:: isinf(a: Scalar) -> bool

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if ``a`` is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(a: Vector[Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the vector ``a`` is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(a: Quaternion[Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the quaternion ``a`` is positive or negative infinity, otherwise return ``False``.


.. py:function:: isinf(a: Matrix[Any,Any,Scalar]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return ``True`` if any element of the matrix ``a`` is positive or negative infinity, otherwise return ``False``.




Vector Math
---------------
.. py:function:: dot(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the dot product between two vectors.


.. py:function:: dot(a: Quaternion[Float], b: Quaternion[Float]) -> Float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the dot product between two quaternions.


.. py:function:: ddot(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the double dot product between two matrices.


.. py:function:: argmin(a: Vector[Any,Scalar]) -> uint32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the index of the minimum element of a vector ``a``.


.. py:function:: argmax(a: Vector[Any,Scalar]) -> uint32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return the index of the maximum element of a vector ``a``.


.. py:function:: outer(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the outer product ``a*b^T`` for two vectors.


.. py:function:: cross(a: Vector[3,Scalar], b: Vector[3,Scalar]) -> Vector[3,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the cross product of two 3D vectors.


.. py:function:: skew(vec: Vector[3,Scalar]) -> Matrix[3,3,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the skew-symmetric 3x3 matrix for a 3D vector ``vec``.


.. py:function:: length(a: Vector[Any,Float]) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the length of a floating-point vector ``a``.


.. py:function:: length(a: Quaternion[Float]) -> Float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the length of a quaternion ``a``.


.. py:function:: length_sq(a: Vector[Any,Scalar]) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the squared length of a vector ``a``.


.. py:function:: length_sq(a: Quaternion[Scalar]) -> Scalar
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the squared length of a quaternion ``a``.


.. py:function:: normalize(a: Vector[Any,Float]) -> Vector[Any,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the normalized value of ``a``. If ``length(a)`` is 0 then the zero vector is returned.


.. py:function:: normalize(a: Quaternion[Float]) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the normalized value of ``a``. If ``length(a)`` is 0, then the zero quaternion is returned.


.. py:function:: transpose(a: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the transpose of the matrix ``a``.


.. py:function:: inverse(a: Matrix[2,2,Float]) -> Matrix[Any,Any,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the inverse of a 2x2 matrix ``a``.


.. py:function:: inverse(a: Matrix[3,3,Float]) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the inverse of a 3x3 matrix ``a``.


.. py:function:: inverse(a: Matrix[4,4,Float]) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the inverse of a 4x4 matrix ``a``.


.. py:function:: determinant(a: Matrix[2,2,Float]) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the determinant of a 2x2 matrix ``a``.


.. py:function:: determinant(a: Matrix[3,3,Float]) -> Float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the determinant of a 3x3 matrix ``a``.


.. py:function:: determinant(a: Matrix[4,4,Float]) -> Float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the determinant of a 4x4 matrix ``a``.


.. py:function:: trace(a: Matrix[Any,Any,Scalar]) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the trace of the matrix ``a``.


.. py:function:: diag(vec: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Returns a matrix with the components of the vector ``vec`` on the diagonal.


.. py:function:: get_diag(mat: Matrix[Any,Any,Scalar]) -> Vector[Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Returns a vector containing the diagonal elements of the square matrix ``mat``.


.. py:function:: cw_mul(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Component-wise multiplication of two vectors.


.. py:function:: cw_mul(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Component-wise multiplication of two matrices.


.. py:function:: cw_div(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Component-wise division of two vectors.


.. py:function:: cw_div(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Component-wise division of two matrices.


.. py:function:: vector(*args: Scalar, length: int32, dtype: Scalar) -> Vector[Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a vector of given length and dtype.


.. py:function:: matrix(pos: Vector[3,Float], rot: Quaternion[Float], scale: Vector[3,Float], dtype: Float) -> Matrix[4,4,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a 4x4 transformation matrix that applies the transformations as
    Translation(pos)*Rotation(rot)*Scaling(scale) when applied to column vectors, i.e.: y = (TRS)*x

    .. versionremoved:: 1.10
       This function has been removed in favor of :func:`warp.math.transform_compose()`.

    .. deprecated:: 1.8


.. py:function:: matrix(*args: Scalar, shape: Tuple[int, int], dtype: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a matrix. If the positional ``arg_types`` are not given, then matrix will be zero-initialized.


.. py:function:: matrix_from_cols(*args: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a matrix from column vectors.


.. py:function:: matrix_from_rows(*args: Vector[Any,Scalar]) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a matrix from row vectors.


.. py:function:: identity(n: int32, dtype: Scalar) -> Matrix[Any,Any,Scalar]

    .. hlist::
       :columns: 8

       * Kernel

    Create an identity matrix with shape=(n,n) with the type given by ``dtype``.


.. py:function:: svd3(A: Matrix[3,3,Float]) -> Tuple[Matrix[3,3,Float], Vector[3,Float], Matrix[3,3,Float]]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the SVD of a 3x3 matrix ``A``. The singular values are returned in ``sigma``,
    while the left and right basis vectors are returned in ``U`` and ``V``.


.. py:function:: svd3(A: Matrix[3,3,Float], U: Matrix[3,3,Float], sigma: Vector[3,Float], V: Matrix[3,3,Float]) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the SVD of a 3x3 matrix ``A``. The singular values are returned in ``sigma``,
    while the left and right basis vectors are returned in ``U`` and ``V``.


.. py:function:: svd2(A: Matrix[2,2,Float]) -> Tuple[Matrix[2,2,Float], Vector[2,Float], Matrix[2,2,Float]]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the SVD of a 2x2 matrix ``A``. The singular values are returned in ``sigma``,
    while the left and right basis vectors are returned in ``U`` and ``V``.


.. py:function:: svd2(A: Matrix[2,2,Float], U: Matrix[2,2,Float], sigma: Vector[2,Float], V: Matrix[2,2,Float]) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the SVD of a 2x2 matrix ``A``. The singular values are returned in ``sigma``,
    while the left and right basis vectors are returned in ``U`` and ``V``.


.. py:function:: qr3(A: Matrix[3,3,Float]) -> Tuple[Matrix[3,3,Float], Matrix[3,3,Float]]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the QR decomposition of a 3x3 matrix ``A``. The orthogonal matrix is returned in ``Q``,
    while the upper triangular matrix is returned in ``R``.


.. py:function:: qr3(A: Matrix[3,3,Float], Q: Matrix[3,3,Float], R: Matrix[3,3,Float]) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the QR decomposition of a 3x3 matrix ``A``. The orthogonal matrix is returned in ``Q``,
    while the upper triangular matrix is returned in ``R``.


.. py:function:: eig3(A: Matrix[3,3,Float]) -> Tuple[Matrix[3,3,Float], Vector[3,Float]]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the eigendecomposition of a 3x3 matrix ``A``. The eigenvectors are returned as the columns of ``Q``,
    while the corresponding eigenvalues are returned in ``d``.


.. py:function:: eig3(A: Matrix[3,3,Float], Q: Matrix[3,3,Float], d: Vector[3,Float]) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the eigendecomposition of a 3x3 matrix ``A``. The eigenvectors are returned as the columns of ``Q``,
    while the corresponding eigenvalues are returned in ``d``.


.. autofunction:: warp.math.norm_l1
.. autofunction:: warp.math.norm_l2
.. autofunction:: warp.math.norm_huber
.. autofunction:: warp.math.norm_pseudo_huber
.. autofunction:: warp.math.smooth_normalize


Quaternion Math
---------------
.. py:function:: quaternion(dtype: Float) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a zero-initialized quaternion. Quaternions are laid out as
    [ix, iy, iz, r], where ix, iy, iz are the imaginary part, and r the real part.


.. py:function:: quaternion(x: Float, y: Float, z: Float, w: Float, dtype: Scalar) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Create a quaternion using the supplied components (type inferred from component type).


.. py:function:: quaternion(ijk: Vector[3,Float], real: Float, dtype: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Create a quaternion using the supplied vector/scalar (type inferred from scalar type).


.. py:function:: quaternion(quat: Quaternion[Float], dtype: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a quaternion of type dtype from another quaternion of a different dtype.


.. py:function:: quat_identity(dtype: Float) -> quatf

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Construct an identity quaternion with zero imaginary part and real part of 1.0


.. py:function:: quat_from_axis_angle(axis: Vector[3,Float], angle: Float) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Construct a quaternion representing a rotation of angle radians around the given axis.


.. py:function:: quat_to_axis_angle(quat: Quaternion[Float]) -> Tuple[Vector[3,Float], Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Extract the rotation axis and angle radians a quaternion represents.


.. py:function:: quat_to_axis_angle(quat: Quaternion[Float], axis: Vector[3,Float], angle: Float) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Extract the rotation axis and angle radians a quaternion represents.


.. py:function:: quat_from_matrix(mat: Matrix[3,3,Float]) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Construct a quaternion from a 3x3 matrix.

    If the matrix is not a pure rotation, but for example includes scaling or skewing, the result is undefined.


.. py:function:: quat_from_matrix(mat: Matrix[4,4,Float]) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Construct a quaternion from a 4x4 matrix.

    If the top-left 3x3 block of the matrix is not a pure rotation, but for example includes scaling or skewing, the result is undefined.


.. py:function:: quat_rpy(roll: Float, pitch: Float, yaw: Float) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. py:function:: quat_inverse(quat: Quaternion[Float]) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute quaternion conjugate.


.. py:function:: quat_rotate(quat: Quaternion[Float], vec: Vector[3,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Rotate a vector by a quaternion.


.. py:function:: quat_rotate_inv(quat: Quaternion[Float], vec: Vector[3,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Rotate a vector by the inverse of a quaternion.


.. py:function:: quat_slerp(a: Quaternion[Float], b: Quaternion[Float], t: Float) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate between two quaternions.


.. py:function:: quat_to_matrix(quat: Quaternion[Float]) -> Matrix[3,3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Convert a quaternion to a 3x3 rotation matrix.




Transformations
---------------
.. py:function:: transformation(p: Vector[3,Float], q: Quaternion[Float], dtype: Float) -> Transformation[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a rigid-body transformation with translation part ``p`` and rotation ``q``.


.. py:function:: transformation(*args: Float, dtype: Float) -> Transformation[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a spatial transform vector of given dtype.


.. py:function:: transform_identity(dtype: Float) -> transformf

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Construct an identity transform with zero translation and identity rotation.


.. py:function:: transform_get_translation(xform: Transformation[Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the translational part of a transform ``xform``.


.. py:function:: transform_get_rotation(xform: Transformation[Float]) -> Quaternion[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the rotational part of a transform ``xform``.


.. py:function:: transform_set_translation(xform: Transformation[Float], p: Vector[3,Float]) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Set the translational part of a transform ``xform``.


.. py:function:: transform_set_rotation(xform: Transformation[Float], q: Quaternion[Float]) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Set the rotational part of a transform ``xform``.


.. py:function:: transform_multiply(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Multiply two rigid body transformations together.


.. py:function:: transform_point(xform: Transformation[Float], point: Vector[3,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Apply the transform to a point ``point`` treating the homogeneous coordinate as w=1 (translation and rotation).


.. py:function:: transform_point(mat: Matrix[4,4,Float], point: Vector[3,Float]) -> Vector[3,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Apply the transform to a point ``point`` treating the homogeneous coordinate as w=1.

    The transformation is applied treating ``point`` as a column vector, e.g.: ``y = mat*point``.

    This is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = point^T*mat^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.


.. py:function:: transform_vector(xform: Transformation[Float], vec: Vector[3,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Apply the transform to a vector ``vec`` treating the homogeneous coordinate as w=0 (rotation only).


.. py:function:: transform_vector(mat: Matrix[4,4,Float], vec: Vector[3,Float]) -> Vector[3,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Apply the transform to a vector ``vec`` treating the homogeneous coordinate as w=0.

    The transformation is applied treating ``vec`` as a column vector, e.g.: ``y = mat*vec``.

    This is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = vec^T*mat^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.


.. py:function:: transform_inverse(xform: Transformation[Float]) -> Transformation[Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the inverse of the transformation ``xform``.


.. autofunction:: warp.math.transform_from_matrix
.. autofunction:: warp.math.transform_to_matrix
.. autofunction:: warp.math.transform_compose
.. autofunction:: warp.math.transform_decompose


Spatial Math
---------------
.. py:function:: spatial_vector(dtype: Float) -> Vector[6,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Zero-initialize a 6D screw vector.


.. py:function:: spatial_vector(w: Vector[3,Float], v: Vector[3,Float], dtype: Float) -> Vector[6,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a 6D screw vector from two 3D vectors.


.. py:function:: spatial_vector(wx: Float, wy: Float, wz: Float, vx: Float, vy: Float, vz: Float, dtype: Float) -> Vector[6,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a 6D screw vector from six values.


.. py:function:: spatial_adjoint(r: Matrix[3,3,Float], s: Matrix[3,3,Float]) -> Matrix[6,6,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Construct a 6x6 spatial inertial matrix from two 3x3 diagonal blocks.


.. py:function:: spatial_dot(a: Vector[6,Float], b: Vector[6,Float]) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the dot product of two 6D screw vectors.


.. py:function:: spatial_cross(a: Vector[6,Float], b: Vector[6,Float]) -> Vector[6,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the cross product of two 6D screw vectors.


.. py:function:: spatial_cross_dual(a: Vector[6,Float], b: Vector[6,Float]) -> Vector[6,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Compute the dual cross product of two 6D screw vectors.


.. py:function:: spatial_top(svec: Vector[6,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the top (first) part of a 6D screw vector.


.. py:function:: spatial_bottom(svec: Vector[6,Float]) -> Vector[3,Float]

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Return the bottom (second) part of a 6D screw vector.


.. py:function:: spatial_jacobian(S: Array[Vector[6,Float]], joint_parents: Array[int32], joint_qd_start: Array[int32], joint_start: int32, joint_count: int32, J_start: int32, J_out: Array[Float]) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable


.. py:function:: spatial_mass(I_s: Array[Matrix[6,6,Float]], joint_start: int32, joint_count: int32, M_start: int32, M: Array[Float]) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable




Tile Primitives
---------------
.. py:function:: tile_zeros(shape: Tuple[int, ...], dtype: Any, storage: str) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Allocate a tile of zero-initialized items.

    :param shape: Shape of the output tile
    :param dtype: Data type of output tile's elements (default float)
    :param storage: The storage location for the tile: ``"register"`` for registers
      (default) or ``"shared"`` for shared memory.
    :returns: A zero-initialized tile with shape and data type as specified


.. py:function:: tile_ones(shape: Tuple[int, ...], dtype: Any, storage: str) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Allocate a tile of one-initialized items.

    :param shape: Shape of the output tile
    :param dtype: Data type of output tile's elements
    :param storage: The storage location for the tile: ``"register"`` for registers
      (default) or ``"shared"`` for shared memory.
    :returns: A one-initialized tile with shape and data type as specified


.. py:function:: tile_full(shape: Tuple[int, ...], value: Any, dtype: Any, storage: str) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Allocate a tile filled with the specified value.

    :param shape: Shape of the output tile
    :param value: Value to fill the tile with
    :param dtype: Data type of output tile's elements
    :param storage: The storage location for the tile: ``"register"`` for registers
      (default) or ``"shared"`` for shared memory.
    :returns: A tile filled with the specified value


.. py:function:: tile_arange(*args: Scalar, dtype: Scalar, storage: str) -> Tile[Scalar,Tuple[int]]

    .. hlist::
       :columns: 8

       * Kernel

    Generate a tile of linearly spaced elements.

    :param args: Variable-length positional arguments, interpreted as:

        - ``(stop,)``: Generates values from ``0`` to ``stop - 1``
        - ``(start, stop)``: Generates values from ``start`` to ``stop - 1``
        - ``(start, stop, step)``: Generates values from ``start`` to ``stop - 1`` with a step size

    :param dtype: Data type of output tile's elements (optional, default: ``float``)
    :param storage: The storage location for the tile: ``"register"`` for registers
      (default) or ``"shared"`` for shared memory.
    :returns: A tile with ``shape=(n)`` with linearly spaced elements of specified data type


.. py:function:: tile_load(a: Array[Any], shape: Tuple[int, ...], offset: Tuple[int, ...], storage: str, bounds_check: bool) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Loads a tile from a global memory array.

    This method will cooperatively load a tile from global memory using all threads in the block.

    :param a: The source array in global memory
    :param shape: Shape of the tile to load, must have the same number of dimensions as ``a``
    :param offset: Offset in the source array to begin reading from (optional)
    :param storage: The storage location for the tile: ``"register"`` for registers
      (default) or ``"shared"`` for shared memory.
    :param bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster load times
    :returns: A tile with shape as specified and data type the same as the source array


.. py:function:: tile_load_indexed(a: Array[Any], indices: Tile[int32,Tuple[int]], shape: Tuple[int, ...], offset: Tuple[int, ...], axis: int32, storage: str) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Loads a tile from a global memory array, with loads along a specified axis mapped according to a 1D tile of indices.

    :param a: The source array in global memory
    :param indices: A 1D tile of integer indices mapping to elements in ``a``.
    :param shape: Shape of the tile to load, must have the same number of dimensions as ``a``, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
    :param offset: Offset in the source array to begin reading from (optional)
    :param axis: Axis of ``a`` that indices refer to
    :param storage: The storage location for the tile: ``"register"`` for registers (default) or ``"shared"`` for shared memory.
    :returns: A tile with shape as specified and data type the same as the source array

    This example shows how to select and store the even indexed rows from a 2D array:

    .. code-block:: python

        TILE_M = wp.constant(2)
        TILE_N = wp.constant(2)
        HALF_M = wp.constant(TILE_M // 2)
        HALF_N = wp.constant(TILE_N // 2)

        @wp.kernel
        def compute(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
            i, j = wp.tid()

            evens = wp.tile_arange(HALF_M, dtype=int, storage="shared") * 2

            t0 = wp.tile_load_indexed(x, indices=evens, shape=(HALF_M, TILE_N), offset=(i*TILE_M, j*TILE_N), axis=0, storage="register")
            wp.tile_store(y, t0, offset=(i*HALF_M, j*TILE_N))

        M = TILE_M * 2
        N = TILE_N * 2

        arr = np.arange(M * N).reshape(M, N)

        x = wp.array(arr, dtype=float)
        y = wp.zeros((M // 2, N), dtype=float)

        wp.launch_tiled(compute, dim=[2,2], inputs=[x], outputs=[y], block_dim=32, device=device)

        print(x.numpy())
        print(y.numpy())

    Prints:

    .. code-block:: text

        [[ 0.  1.  2.  3.]
         [ 4.  5.  6.  7.]
         [ 8.  9. 10. 11.]
         [12. 13. 14. 15.]]

        [[ 0.  1.  2.  3.]
         [ 8.  9. 10. 11.]]
    


.. py:function:: tile_store(a: Array[Any], t: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...], bounds_check: bool) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Store a tile to a global memory array.

    This method will cooperatively store a tile to global memory using all threads in the block.

    :param a: The destination array in global memory
    :param t: The source tile to store data from, must have the same data type and number of dimensions as the destination array
    :param offset: Offset in the destination array (optional)
    :param bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster write times
    


.. py:function:: tile_store_indexed(a: Array[Any], indices: Tile[int32,Tuple[int]], t: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...], axis: int32) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Store a tile to a global memory array, with storage along a specified axis mapped according to a 1D tile of indices.

    :param a: The destination array in global memory
    :param indices: A 1D tile of integer indices mapping to elements in ``a``.
    :param t: The source tile to store data from, must have the same data type and number of dimensions as the destination array, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
    :param offset: Offset in the destination array (optional)
    :param axis: Axis of ``a`` that indices refer to

    This example shows how to map tile rows to the even rows of a 2D array:

    .. code-block:: python

        TILE_M = wp.constant(2)
        TILE_N = wp.constant(2)
        TWO_M = wp.constant(TILE_M * 2)
        TWO_N = wp.constant(TILE_N * 2)

        @wp.kernel
        def compute(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
            i, j = wp.tid()

            t = wp.tile_load(x, shape=(TILE_M, TILE_N), offset=(i*TILE_M, j*TILE_N), storage="register")

            evens_M = wp.tile_arange(TILE_M, dtype=int, storage="shared") * 2

            wp.tile_store_indexed(y, indices=evens_M, t=t, offset=(i*TWO_M, j*TILE_N), axis=0)

        M = TILE_M * 2
        N = TILE_N * 2

        arr = np.arange(M * N, dtype=float).reshape(M, N)

        x = wp.array(arr, dtype=float, requires_grad=True, device=device)
        y = wp.zeros((M * 2, N), dtype=float, requires_grad=True, device=device)

        wp.launch_tiled(compute, dim=[2,2], inputs=[x], outputs=[y], block_dim=32, device=device)

        print(x.numpy())
        print(y.numpy())

    Prints:

    .. code-block:: text

        [[ 0.  1.  2.  3.]
         [ 4.  5.  6.  7.]
         [ 8.  9. 10. 11.]
         [12. 13. 14. 15.]]

        [[ 0.  1.  2.  3.]
         [ 0.  0.  0.  0.]
         [ 4.  5.  6.  7.]
         [ 0.  0.  0.  0.]
         [ 8.  9. 10. 11.]
         [ 0.  0.  0.  0.]
         [12. 13. 14. 15.]
         [ 0.  0.  0.  0.]]
    


.. py:function:: tile_atomic_add(a: Array[Any], t: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...], bounds_check: bool) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically add a tile onto the array `a`, each element will be updated atomically.

    :param a: Array in global memory, should have the same ``dtype`` as the input tile
    :param t: Source tile to add to the destination array
    :param offset: Offset in the destination array (optional)
    :param bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster write times
    :returns: A tile with the same dimensions and data type as the source tile, holding the original value of the destination elements


.. py:function:: tile_atomic_add_indexed(a: Array[Any], indices: Tile[int32,Tuple[int]], t: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...], axis: int32) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically add a tile to a global memory array, with storage along a specified axis mapped according to a 1D tile of indices.

    :param a: The destination array in global memory
    :param indices: A 1D tile of integer indices mapping to elements in ``a``.
    :param t: The source tile to extract data from, must have the same data type and number of dimensions as the destination array, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
    :param offset: Offset in the destination array (optional)
    :param axis: Axis of ``a`` that indices refer to

    This example shows how to compute a blocked, row-wise reduction:

    .. code-block:: python

        TILE_M = wp.constant(2)
        TILE_N = wp.constant(2)

        @wp.kernel
        def tile_atomic_add_indexed(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
            i, j = wp.tid()

            t = wp.tile_load(x, shape=(TILE_M, TILE_N), offset=(i*TILE_M, j*TILE_N), storage="register")

            zeros = wp.tile_zeros(TILE_M, dtype=int, storage="shared")

            wp.tile_atomic_add_indexed(y, indices=zeros, t=t, offset=(i, j*TILE_N), axis=0)

        M = TILE_M * 2
        N = TILE_N * 2

        arr = np.arange(M * N, dtype=float).reshape(M, N)

        x = wp.array(arr, dtype=float, requires_grad=True, device=device)
        y = wp.zeros((2, N), dtype=float, requires_grad=True, device=device)

        wp.launch_tiled(tile_atomic_add_indexed, dim=[2,2], inputs=[x], outputs=[y], block_dim=32, device=device)

        print(x.numpy())
        print(y.numpy())

    Prints:

    .. code-block:: text

        [[ 0.  1.  2.  3.]
         [ 4.  5.  6.  7.]
         [ 8.  9. 10. 11.]
         [12. 13. 14. 15.]]

        [[ 4.  6.  8. 10.]
         [20. 22. 24. 26.]]
    


.. py:function:: tile_view(t: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...], shape: Tuple[int, ...]) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Return a slice of a given tile [offset, offset+shape], if shape is not specified it will be inferred from the unspecified offset dimensions.

    :param t: Input tile to extract a subrange from
    :param offset: Offset in the source tile
    :param shape: Shape of the returned slice
    :returns: A tile with dimensions given by the specified shape or the remaining source tile dimensions


.. py:function:: tile_squeeze(t: Tile[Any,Tuple[int, ...]], axis: Tuple[int, ...]) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Return a squeezed view of a tile with the same data.

    :param t: Input tile to squeeze
    :param axis: A subset of the entries of length one in the shape (optional)
    :returns: The input tile but with all or a subset of the dimensions of length one removed.


.. py:function:: tile_reshape(t: Tile[Any,Tuple[int, ...]], shape: Tuple[int, ...]) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Return a reshaped view of a tile with the same data.

    :param t: Input tile to reshape
    :param shape: New shape for the tile
    :returns: A tile containing the same data as the input tile, but arranged in a new shape.


.. py:function:: tile_astype(t: Tile[Scalar,Tuple[int, ...]], dtype: Scalar) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Return a new tile with the same data as the input tile, but with a different data type.

    :param t: Input tile
    :param dtype: New data type for the tile
    :returns: A tile with the same data as the input tile, but with a different data type


.. py:function:: tile_assign(dst: Tile[Any,Tuple[int, ...]], src: Tile[Any,Tuple[int, ...]], offset: Tuple[int, ...]) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Assign a tile to a subrange of a destination tile.

    :param dst: The destination tile to assign to
    :param src: The source tile to read values from
    :param offset: Offset in the destination tile to write to


.. py:function:: untile(a: Tile[Any,Tuple[int, ...]]) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Convert a tile back to per-thread values.

    This function converts a block-wide tile back to per-thread values.

    * If the input tile is 1D, then the resulting value will be a per-thread scalar
    * If the input tile is 2D, then the resulting value will be a per-thread vector of length M

    :param a: A tile with dimensions ``shape=(M, block_dim)``
    :returns: A single value per-thread with the same data type as the tile

    This example shows how to create a linear sequence from thread variables:

    .. code-block:: python

        @wp.kernel
        def compute():
            i = wp.tid()

            # create block-wide tile
            t = wp.tile(i)*2

            # convert back to per-thread values
            s = wp.untile(t)

            print(s)

        wp.launch(compute, dim=16, inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        0
        2
        4
        6
        8
        ...
    


.. py:function:: tile_transpose(a: Tile[Any,Tuple[int, int]]) -> Tile[Any,Tuple[int, int]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Transpose a tile.

    For shared memory tiles, this operation will alias the input tile.
    Register tiles will first be transferred to shared memory before transposition.

    :param a: Tile to transpose with ``shape=(M,N)``
    :returns: Tile with ``shape=(N,M)``


.. py:function:: tile_broadcast(a: Tile[Any,Tuple[int, ...]], shape: Tuple[int, ...]) -> Tile[Any,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Broadcast a tile.

    Broadcasts the input tile ``a`` to the destination shape.
    Broadcasting follows NumPy broadcast rules.

    :param a: Tile to broadcast
    :param shape: The shape to broadcast to
    :returns: Tile with broadcast shape


.. py:function:: tile_sum(a: Tile[Scalar,Tuple[int, ...]], axis: int32) -> Tile[Scalar,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Cooperatively compute the sum of the tile elements across an axis of the tile using all threads in the block.

    :param a: The input tile. Must reside in shared memory.
    :param axis: The tile axis to compute the sum across. Must be a compile-time constant.
    :returns: A tile with the same shape as the input tile less the axis dimension and the same data type as the input tile.

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_ones(dtype=float, shape=(8, 8))
            s = wp.tile_sum(t, axis=0)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [8 8 8 8 8 8 8 8] = tile(shape=(8), storage=register)

    


.. py:function:: tile_sum(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[1]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Cooperatively compute the sum of the tile elements using all threads in the block.

    :param a: The tile to compute the sum of
    :returns: A single-element tile holding the sum

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_ones(dtype=float, shape=(16, 16))
            s = wp.tile_sum(t)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [256] = tile(shape=(1), storage=register)

    


.. py:function:: tile_sort(keys: Tile[Any,Tuple[int]], values: Tile[Any,Tuple[int]]) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Cooperatively sort the elements of two tiles in ascending order based on the keys, using all threads in the block.

    :param keys: Keys to sort by. Supported key types: :class:`float32`, :class:`int32`, :class:`uint32`. Must be in shared memory.
    :param values: Values to sort along with keys. No type restrictions. Must be in shared memory.
    :returns: No return value. Sorts both tiles in-place.

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            keys = wp.tile_arange(32, 0, -1, dtype=int, storage="shared")
            values = wp.tile_arange(0, 32, 1, dtype=int, storage="shared")
            wp.tile_sort(keys, values)

            print(keys)
            print(values)


        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [1, 2, ..., 32] = tile(shape=(32), storage=shared)
        [31, 30, 29, ..., 0] = tile(shape=(32), storage=shared)

    


.. py:function:: tile_min(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[1]]

    .. hlist::
       :columns: 8

       * Kernel

    Cooperatively compute the minimum of the tile elements using all threads in the block.

    :param a: The tile to compute the minimum of
    :returns: A single-element tile holding the minimum value

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_arange(64, 128)
            s = wp.tile_min(t)

            print(s)


        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [64] = tile(shape=(1), storage=register)

    


.. py:function:: tile_argmin(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Int,Tuple[1]]

    .. hlist::
       :columns: 8

       * Kernel

    Cooperatively compute the index of the minimum element in the tile using all threads in the block.

    :param a: The tile to compute the argmin from
    :returns: A single-element tile holding the index of the minimum value

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_arange(64, 128)
            s = wp.tile_argmin(t)

            print(s)


        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [0] = tile(shape=(1), storage=register)

    


.. py:function:: tile_max(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[1]]

    .. hlist::
       :columns: 8

       * Kernel

    Cooperatively compute the maximum of the tile elements using all threads in the block.

    :param a: The tile to compute the maximum from
    :returns: A single-element tile holding the maximum value

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_arange(64, 128)
            s = wp.tile_max(t)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [127] = tile(shape=(1), storage=register)

    


.. py:function:: tile_argmax(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Int,Tuple[1]]

    .. hlist::
       :columns: 8

       * Kernel

    Cooperatively compute the index of the maximum element in the tile using all threads in the block.

    :param a: The tile to compute the argmax from
    :returns: A single-element tile holding the index of the maximum value

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_arange(64, 128)
            s = wp.tile_argmax(t)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

    Prints:

    .. code-block:: text

        [63] = tile(shape=(1), storage=register)

    


.. py:function:: tile_reduce(op: Callable, a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[1]]

    .. hlist::
       :columns: 8

       * Kernel

    Apply a custom reduction operator across the tile.

    This function cooperatively performs a reduction using the provided operator across the tile.

    :param op: A callable function that accepts two arguments and returns one argument, may be a user function or builtin
    :param a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type
    :returns: A single-element tile with the same data type as the input tile.

    Example:

    .. code-block:: python

        @wp.kernel
        def factorial():

            t = wp.tile_arange(1, 10, dtype=int)
            s = wp.tile_reduce(wp.mul, t)

            print(s)

        wp.launch_tiled(factorial, dim=[1], inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        [362880] = tile(shape=(1), storage=register)
    


.. py:function:: tile_reduce(op: Callable, a: Tile[Scalar,Tuple[int, ...]], axis: int32) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Apply a custom reduction operator across a tile axis.

    This function cooperatively performs a reduction using the provided operator across an axis of the tile.

    :param op: A callable function that accepts two arguments and returns one argument, may be a user function or builtin
    :param a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type. Must reside in shared memory.
    :param axis: The tile axis to perform the reduction across. Must be a compile-time constant.
    :returns: A tile with the same shape as the input tile less the axis dimension and the same data type as the input tile.

    Example:

    .. code-block:: python

        TILE_M = wp.constant(4)
        TILE_N = wp.constant(2)

        @wp.kernel
        def compute(x: wp.array2d(dtype=float), y: wp.array(dtype=float)):

            a = wp.tile_load(x, shape=(TILE_M, TILE_N))
            b = wp.tile_reduce(wp.add, a, axis=1)
            wp.tile_store(y, b)

        arr = np.arange(TILE_M * TILE_N).reshape(TILE_M, TILE_N)

        x = wp.array(arr, dtype=float)
        y = wp.zeros(TILE_M, dtype=float)

        wp.launch_tiled(compute, dim=[1], inputs=[x], outputs=[y], block_dim=32)

        print(x.numpy())
        print(y.numpy())

    Prints:

    .. code-block:: text

        [[0. 1.]
         [2. 3.]
         [4. 5.]
         [6. 7.]]
        [ 1.  5.  9. 13.]
    


.. py:function:: tile_scan_inclusive(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Inclusive scan (prefix sum) across the tile.

    This function cooperatively performs an inclusive scan (cumulative sum) across the tile.

    :param a: The input tile. Must be a tile of type float32, int32, or uint32.
    :returns: A new tile containing the inclusive scan result.

    Example:

    .. code-block:: python

        @wp.kernel
        def scan_example():
            t = wp.tile_arange(1, 5, dtype=int)
            s = wp.tile_scan_inclusive(t)
            print(s)

        wp.launch_tiled(scan_example, dim=[1], inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        [1, 3, 6, 10] = tile(shape=(4), storage=register)
    


.. py:function:: tile_scan_exclusive(a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel

    Exclusive scan (prefix sum) across the tile.

    This function cooperatively performs an exclusive scan (cumulative sum) across the tile.

    :param a: The input tile. Must be a tile of type float32, int32, or uint32.
    :returns: A new tile containing the exclusive scan result.

    Example:

    .. code-block:: python

        @wp.kernel
        def scan_example():
            t = wp.tile_arange(1, 5, dtype=int)
            s = wp.tile_scan_exclusive(t)
            print(s)

        wp.launch_tiled(scan_example, dim=[1], inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        [0, 1, 3, 6] = tile(shape=(4), storage=register)
    


.. py:function:: tile_map(op: Callable, a: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Apply a unary function onto the tile.

    This function cooperatively applies a unary function to each element of the tile using all threads in the block.

    :param op: A callable function that accepts one argument and returns one argument, may be a user function or builtin
    :param a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type
    :returns: A tile with the same dimensions as the input tile. Its datatype is specified by the return type of op

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            t = wp.tile_arange(0.0, 1.0, 0.1, dtype=float)
            s = wp.tile_map(wp.sin, t)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        [0 0.0998334 0.198669 0.29552 0.389418 0.479426 0.564642 0.644218 0.717356 0.783327] = tile(shape=(10), storage=register)
    


.. py:function:: tile_map(op: Callable, a: Tile[Scalar,Tuple[int, ...]], b: Tile[Scalar,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Apply a binary function onto the tile.

    This function cooperatively applies a binary function to each element of the tiles using all threads in the block.
    Both input tiles must have the same dimensions, and if using a builtin op, the same datatypes.

    :param op: A callable function that accepts two arguments and returns one argument, all of the same type, may be a user function or builtin
    :param a: The first input tile, the operator (or one of its overloads) must be able to accept the tile's dtype
    :param b: The second input tile, the operator (or one of its overloads) must be able to accept the tile's dtype
    :returns: A tile with the same dimensions as the input tiles. Its datatype is specified by the return type of op

    Example:

    .. code-block:: python

        @wp.kernel
        def compute():

            a = wp.tile_arange(0.0, 1.0, 0.1, dtype=float)
            b = wp.tile_ones(shape=10, dtype=float)

            s = wp.tile_map(wp.add, a, b)

            print(s)

        wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=16)

    Prints:

    .. code-block:: text

        [1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9] = tile(shape=(10), storage=register)


.. py:function:: tile_diag_add(a: Tile[Any,Tuple[int, int]], d: Tile[Any,Tuple[int]]) -> Tile[Any,Tuple[int, int]]

    .. hlist::
       :columns: 8

       * Kernel

    Add a square matrix and a diagonal matrix 'd' represented as a 1D tile


.. py:function:: tile_matmul(a: Tile[Float,Tuple[int, int]], b: Tile[Float,Tuple[int, int]], out: Tile[Float,Tuple[int, int]], alpha: Float, beta: Float) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the matrix product and accumulates ``out = alpha * a*b + beta * out``.

    Supported datatypes are:
        * fp16, fp32, fp64 (real)
        * vec2h, vec2f, vec2d (complex)

    All input and output tiles must have the same datatype. Tile data will automatically be migrated
    to shared memory if necessary and will use TensorCore operations when available.

    Note that computing the adjoints of alpha and beta are not yet supported.

    :param a: A tile with ``shape=(M, K)``
    :param b: A tile with ``shape=(K, N)``
    :param out: A tile with ``shape=(M, N)``
    :param alpha: Scaling factor (default 1.0)
    :param beta: Accumulator factor (default 1.0)
    


.. py:function:: tile_matmul(a: Tile[Float,Tuple[int, int]], b: Tile[Float,Tuple[int, int]], alpha: Float) -> Tile[Float,Tuple[int, int]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the matrix product ``out = alpha * a*b``.

    Supported datatypes are:
        * fp16, fp32, fp64 (real)
        * vec2h, vec2f, vec2d (complex)

    Both input tiles must have the same datatype. Tile data will automatically be migrated
    to shared memory if necessary and will use TensorCore operations when available.

    Note that computing the adjoints of alpha is not yet supported.

    :param a: A tile with ``shape=(M, K)``
    :param b: A tile with ``shape=(K, N)``
    :param alpha: Scaling factor (default 1.0)
    :returns: A tile with ``shape=(M, N)``
    


.. py:function:: tile_fft(inout: Tile[Vector[2,Float],Tuple[int, int]]) -> Tile[Vector[2,Float],Tuple[int, int]]

    .. hlist::
       :columns: 8

       * Kernel

    Compute the forward FFT along the second dimension of a 2D tile of data.

    This function cooperatively computes the forward FFT on a tile of data inplace, treating each row individually.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * vec2f, vec2d

    :param inout: The input/output tile


.. py:function:: tile_ifft(inout: Tile[Vector[2,Float],Tuple[int, int]]) -> Tile[Vector[2,Float],Tuple[int, int]]

    .. hlist::
       :columns: 8

       * Kernel

    Compute the inverse FFT along the second dimension of a 2D tile of data.

    This function cooperatively computes the inverse FFT on a tile of data inplace, treating each row individually.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * vec2f, vec2d

    :param inout: The input/output tile


.. py:function:: tile_cholesky(A: Tile[Float,Tuple[int, int]]) -> Tile[Float,Tuple[int, int]]

    .. hlist::
       :columns: 8

       * Kernel

    Compute the Cholesky factorization L of a matrix A.
    L is lower triangular and satisfies LL^T = A.

    Only the lower triangular portion of A is used for the decomposition;
    the upper triangular part may be left unspecified.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    :param A: A square, symmetric positive-definite, matrix. Only the lower triangular part of A is needed; the upper part is ignored.
    :returns L: A square, lower triangular, matrix, such that LL^T = A


.. py:function:: tile_cholesky_solve(L: Tile[Float,Tuple[int, int]], y: Tile[Float,Tuple[int]]) -> None

    .. hlist::
       :columns: 8

       * Kernel

    With L such that LL^T = A, solve for x in Ax = y

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    :param L: A square, lower triangular, matrix, such that LL^T = A
    :param y: A 1D or 2D tile of length M
    :returns x: A tile of the same shape as y such that LL^T x = y


.. py:function:: tile_lower_solve(L: Tile[Float,Tuple[int, int]], y: Tile[Float,Tuple[int]]) -> Tile[Float,Tuple[int]]

    .. hlist::
       :columns: 8

       * Kernel

    Solve for z in Lz = y, where L is a lower triangular matrix.

    This performs general forward substitution for a lower triangular system.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    :param L: A square, non-singular, lower triangular matrix
    :param y: A 1D or 2D tile with compatible shape
    :returns z: A tile of the same shape as y such that Lz = y


.. py:function:: tile_upper_solve(U: Tile[Float,Tuple[int, int]], z: Tile[Float,Tuple[int]]) -> Tile[Float,Tuple[int]]

    .. hlist::
       :columns: 8

       * Kernel

    Solve for x in U x = z, where U is an upper triangular matrix.

    This performs general back substitution for upper triangular systems.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    :param U: A square, non-singular, upper triangular matrix
    :param z: A 1D or 2D tile with compatible shape
    :returns x: A tile of the same shape as z such that U x = z




Utility
---------------
.. py:function:: reversed(range: range_t) -> range_t

    .. hlist::
       :columns: 8

       * Kernel

    Returns the range in reversed order.


.. py:function:: printf(fmt: str, *args: Any) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Allows printing formatted strings using C-style format specifiers.


.. py:function:: print(value: Any) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Print variable to stdout


.. py:function:: breakpoint() -> None

    .. hlist::
       :columns: 8

       * Kernel

    Debugger breakpoint


.. py:function:: tid() -> int

    .. hlist::
       :columns: 8

       * Kernel

    Return the current thread index for a 1D kernel launch.

    Note that this is the *global* index of the thread in the range [0, dim)
    where dim is the parameter passed to kernel launch.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the current thread indices for a 2D kernel launch.

    Use ``i,j = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int, int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the current thread indices for a 3D kernel launch.

    Use ``i,j,k = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: tid() -> Tuple[int, int, int, int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the current thread indices for a 4D kernel launch.

    Use ``i,j,k,l = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.

    This function may not be called from user-defined Warp functions.


.. py:function:: block_dim() -> int

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Returns the number of threads in the current block.


.. py:function:: select(cond: bool, value_if_false: Any, value_if_true: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: int8, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: uint8, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: int16, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: uint16, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: int32, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: uint32, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: int64, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(cond: uint64, value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: select(arr: Array[Any], value_if_false: Any, value_if_true: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``arr`` is null then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
         Use :func:`where` instead, which has the more intuitive argument order:
         ``where(arr, value_if_true, value_if_false)``.

    .. deprecated:: 1.7


.. py:function:: where(cond: bool, value_if_true: Any, value_if_false: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: int8, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: uint8, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: int16, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: uint16, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: int32, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: uint32, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: int64, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(cond: uint64, value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: where(arr: Array[Any], value_if_true: Any, value_if_false: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Select between two arguments, if ``arr`` is not null then return ``value_if_true``, otherwise return ``value_if_false``.


.. py:function:: atomic_add(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] += value``.


.. py:function:: atomic_add(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] += value``.


.. py:function:: atomic_add(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.


.. py:function:: atomic_add(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] += value``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] += value``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.


.. py:function:: atomic_add(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] += value``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] += value``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.


.. py:function:: atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.


.. py:function:: atomic_sub(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] -= value``.


.. py:function:: atomic_sub(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] -= value``.


.. py:function:: atomic_sub(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.


.. py:function:: atomic_sub(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] -= value``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] -= value``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.


.. py:function:: atomic_sub(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.
        This function is automatically invoked when using the syntax ``arr[i] -= value``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.
        This function is automatically invoked when using the syntax ``arr[i,j] -= value``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.


.. py:function:: atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.


.. py:function:: atomic_min(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: Array[Any], i: Int, compare: Any, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: Array[Any], i: Int, j: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: Array[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: FabricArray[Any], i: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: FabricArray[Any], i: Int, j: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: FabricArray[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: IndexedFabricArray[Any], i: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.


.. py:function:: atomic_and(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] &= value``.


.. py:function:: atomic_and(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] &= value``.


.. py:function:: atomic_and(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.


.. py:function:: atomic_and(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.


.. py:function:: atomic_and(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] &= value``.


.. py:function:: atomic_and(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] &= value``.


.. py:function:: atomic_and(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.


.. py:function:: atomic_and(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.


.. py:function:: atomic_and(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] &= value``.


.. py:function:: atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] &= value``.


.. py:function:: atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.


.. py:function:: atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.


.. py:function:: atomic_or(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] |= value``.


.. py:function:: atomic_or(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] |= value``.


.. py:function:: atomic_or(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.


.. py:function:: atomic_or(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.


.. py:function:: atomic_or(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] |= value``.


.. py:function:: atomic_or(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] |= value``.


.. py:function:: atomic_or(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.


.. py:function:: atomic_or(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.


.. py:function:: atomic_or(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] |= value``.


.. py:function:: atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] |= value``.


.. py:function:: atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.


.. py:function:: atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.


.. py:function:: atomic_xor(arr: Array[Any], i: Int, value: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] ^= value``.


.. py:function:: atomic_xor(arr: Array[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.


.. py:function:: atomic_xor(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.


.. py:function:: atomic_xor(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.


.. py:function:: atomic_xor(arr: FabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] ^= value``.


.. py:function:: atomic_xor(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.


.. py:function:: atomic_xor(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.


.. py:function:: atomic_xor(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.


.. py:function:: atomic_xor(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i] ^= value``.


.. py:function:: atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.


.. py:function:: atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.


.. py:function:: atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.
        This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.


.. py:function:: lerp(a: Float, b: Float, t: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Vector[Any,Float], b: Vector[Any,Float], t: Float) -> Vector[Any,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Matrix[Any,Any,Float], b: Matrix[Any,Any,Float], t: Float) -> Matrix[Any,Any,Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Quaternion[Float], b: Quaternion[Float], t: Float) -> Quaternion[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: lerp(a: Transformation[Float], b: Transformation[Float], t: Float) -> Transformation[Float]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``


.. py:function:: smoothstep(a: Float, b: Float, x: Float) -> Float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Smoothly interpolate between two values ``a`` and ``b`` using a factor ``x``,
    and return a result between 0 and 1 using a cubic Hermite interpolation after clamping.


.. py:function:: expect_near(a: Float, b: Float, tolerance: Float) -> None

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Prints an error to stdout if ``a`` and ``b`` are not closer than tolerance in magnitude


.. py:function:: expect_near(a: Vector[Any,Float], b: Vector[Any,Float], tolerance: Float) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Prints an error to stdout if any element of ``a`` and ``b`` are not closer than tolerance in magnitude


.. py:function:: expect_near(a: Quaternion[Float], b: Quaternion[Float], tolerance: Float) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Prints an error to stdout if any element of ``a`` and ``b`` are not closer than tolerance in magnitude


.. py:function:: expect_near(a: Matrix[Any,Any,Float], b: Matrix[Any,Any,Float], tolerance: Float) -> None
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Prints an error to stdout if any element of ``a`` and ``b`` are not closer than tolerance in magnitude


.. py:function:: len(a: Vector[Any,Scalar]) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of elements in a vector.


.. py:function:: len(a: Quaternion[Scalar]) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of elements in a quaternion.


.. py:function:: len(a: Matrix[Any,Any,Scalar]) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of rows in a matrix.


.. py:function:: len(a: Transformation[Float]) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of elements in a transformation.


.. py:function:: len(a: Array[Any]) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the size of the first dimension in an array.


.. py:function:: len(a: Tile[Any,Tuple[int, ...]]) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of rows in a tile.


.. py:function:: len(a: Tuple) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Return the number of elements in a tuple.


.. py:function:: cast(a: Any, dtype: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Reinterpret a value as a different type while preserving its bit pattern.




Geometry
---------------
.. autoclass:: warp.BvhQuery
   :exclude-members: Var, vars
.. py:function:: bvh_query_aabb(id: uint64, low: vec3f, high: vec3f, root: int32) -> BvhQuery

    .. hlist::
       :columns: 8

       * Kernel

    Construct an axis-aligned bounding box query against a BVH object.

    This query can be used to iterate over all bounds inside a BVH.
    To start a query from a specific node, set ``root`` to the index of the node. The root
    can be obtained using the :func:`bvh_get_group_root` function when creating a grouped BVH.
    If ``root`` is -1 (default), traversal starts at the BVH's global root.
    The query will only trace down from that node, limiting traversal to that subtree.

    :param id: The BVH identifier
    :param low: The lower bound of the bounding box in BVH space
    :param high: The upper bound of the bounding box in BVH space
    :param root: The root to begin the query from (optional, default: -1)


.. py:function:: bvh_query_ray(id: uint64, start: vec3f, dir: vec3f, root: int32) -> BvhQuery

    .. hlist::
       :columns: 8

       * Kernel

    Construct a ray query against a BVH object.

    This query can be used to iterate over all bounds that intersect the ray.
    To start a query from a specific node, set ``root`` to the index of the node. The root
    can be obtained using the :func:`bvh_get_group_root` function when creating a grouped BVH.
    If ``root`` is -1 (default), traversal starts at the BVH's global root.
    The query will only trace down from that node, limiting traversal to that subtree.

    :param id: The BVH identifier
    :param start: The start of the ray in BVH space
    :param dir: The direction of the ray in BVH space
    :param root: The root to begin the query from (optional, default: -1)


.. py:function:: bvh_query_next(query: BvhQuery, index: int32, max_dist: float32) -> bool

    .. hlist::
       :columns: 8

       * Kernel

    Move to the next bound returned by the query.

    The index of the current bound is stored in ``index``, returns ``False`` if there are no more overlapping bounds.
    The maximum distance along a ray query to check for intersections can be set using ``max_dist``.

    :param query: The query to move to the next bound
    :param index: The index of the current bound
    :param max_dist: The maximum distance along the ray to check for intersections for ray queries


.. py:function:: bvh_get_group_root(id: uint64, group: int32) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Get the root of a group in a BVH.

    Returns the root node index for the specified group. If the group does not exist, returns ``-1``
    (sentinel for the BVH global root). Pass ``-1`` to BVH queries to traverse from the global root.

    :param id: The BVH identifier
    :param group: The group identifier


.. autoclass:: warp.MeshQueryPoint
   :exclude-members: Var, vars
.. py:function:: mesh_query_point(id: uint64, point: vec3f, max_dist: float32) -> MeshQueryPoint

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance using additional ray-casts to determine if the point is inside or outside.
    This method is relatively robust, but does increase computational cost.
    See below for additional sign determination methods.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query


.. py:function:: mesh_query_point_no_sign(id: uint64, point: vec3f, max_dist: float32) -> MeshQueryPoint

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    This method does not compute the sign of the point (inside/outside) which makes it faster than other point query methods.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query


.. py:function:: mesh_query_furthest_point_no_sign(id: uint64, point: vec3f, min_dist: float32) -> MeshQueryPoint

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the furthest point on the mesh with identifier `id` to the given point in space.

    This method does not compute the sign of the point (inside/outside).

    :param id: The mesh identifier
    :param point: The point in space to query
    :param min_dist: Mesh faces below this distance will not be considered by the query


.. py:function:: mesh_query_point_sign_normal(id: uint64, point: vec3f, max_dist: float32, epsilon: float32) -> MeshQueryPoint

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance (inside/outside) using the angle-weighted pseudo normal.
    This approach to sign determination is robust for well conditioned meshes that are watertight and non-self intersecting.
    It is also comparatively fast to compute.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query
    :param epsilon: Epsilon treating distance values as equal, when locating the minimum distance vertex/face/edge, as a
                    fraction of the average edge length, also for treating closest point as being on edge/vertex default 1e-3


.. py:function:: mesh_query_point_sign_winding_number(id: uint64, point: vec3f, max_dist: float32, accuracy: float32, threshold: float32) -> MeshQueryPoint

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the closest point on the :class:`Mesh` with identifier ``id`` to the given point in space.

    Identifies the sign using the winding number of the mesh relative to the query point. This method of sign determination is robust for poorly conditioned meshes
    and provides a smooth approximation to sign even when the mesh is not watertight. This method is the most robust and accurate of the sign determination meshes
    but also the most expensive.

    .. note:: The :class:`Mesh` object must be constructed with ``support_winding_number=True`` for this method to return correct results.

    :param id: The mesh identifier
    :param point: The point in space to query
    :param max_dist: Mesh faces above this distance will not be considered by the query
    :param accuracy: Accuracy for computing the winding number with fast winding number method utilizing second-order dipole approximation, default 2.0
    :param threshold: The threshold of the winding number to be considered inside, default 0.5


.. autoclass:: warp.MeshQueryRay
   :exclude-members: Var, vars
.. py:function:: mesh_query_ray(id: uint64, start: vec3f, dir: vec3f, max_t: float32) -> MeshQueryRay

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Computes the closest ray hit on the :class:`Mesh` with identifier ``id``.

    :param id: The mesh identifier
    :param start: The start point of the ray
    :param dir: The ray direction (should be normalized)
    :param max_t: The maximum distance along the ray to check for intersections


.. autoclass:: warp.MeshQueryAABB
   :exclude-members: Var, vars
.. py:function:: mesh_query_aabb(id: uint64, low: vec3f, high: vec3f) -> MeshQueryAABB

    .. hlist::
       :columns: 8

       * Kernel

    Construct an axis-aligned bounding box query against a :class:`Mesh`.

    This query can be used to iterate over all bounding boxes of the triangles inside a volume.

    :param id: The mesh identifier
    :param low: The lower bound of the bounding box in mesh space
    :param high: The upper bound of the bounding box in mesh space


.. py:function:: mesh_query_aabb_next(query: MeshQueryAABB, index: int32) -> bool

    .. hlist::
       :columns: 8

       * Kernel

    Move to the next triangle whose bounding box overlaps the query bounding box.

    The index of the current face is stored in ``index``, returns ``False`` if there are no more overlapping triangles.


.. py:function:: mesh_eval_position(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Evaluates the position on the :class:`Mesh` given a face index and barycentric coordinates.


.. py:function:: mesh_eval_velocity(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Evaluates the velocity on the :class:`Mesh` given a face index and barycentric coordinates.


.. autoclass:: warp.HashGridQuery
   :exclude-members: Var, vars
.. py:function:: hash_grid_query(id: uint64, point: vec3f, max_dist: float32) -> HashGridQuery

    .. hlist::
       :columns: 8

       * Kernel

    Construct a point query against a :class:`HashGrid`.

    This query can be used to iterate over all neighboring point within a fixed radius from the query point.


.. py:function:: hash_grid_query_next(query: HashGridQuery, index: int32) -> bool

    .. hlist::
       :columns: 8

       * Kernel

    Move to the next point in the hash grid query.

    The index of the current neighbor is stored in ``index``, returns ``False`` if there are no more neighbors.


.. py:function:: hash_grid_point_id(id: uint64, index: int32) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Return the index of a point in the :class:`HashGrid`.

    This can be used to reorder threads such that grid traversal occurs in a spatially coherent order.

    Returns -1 if the :class:`HashGrid` has not been reserved.


.. py:function:: intersect_tri_tri(v0: vec3f, v1: vec3f, v2: vec3f, u0: vec3f, u1: vec3f, u2: vec3f) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Tests for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Moller's method.

    This function works with single precision, may return incorrect results in some case.

    Returns > 0 if triangles intersect.


.. py:function:: intersect_tri_tri(v0: vec3d, v1: vec3d, v2: vec3d, u0: vec3d, u1: vec3d, u2: vec3d) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Tests for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Moller's method.

    This function works with double precision, results are more accurate than the single precision version.

    Returns > 0 if triangles intersect.


.. py:function:: mesh_get(id: uint64) -> Mesh

    .. hlist::
       :columns: 8

       * Kernel

    Retrieves the mesh given its index.


.. py:function:: mesh_eval_face_normal(id: uint64, face: int32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel

    Evaluates the face normal the mesh given a face index.


.. py:function:: mesh_get_point(id: uint64, index: int32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel

    Returns the point of the mesh given a index.


.. py:function:: mesh_get_velocity(id: uint64, index: int32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel

    Returns the velocity of the mesh given a index.


.. py:function:: mesh_get_index(id: uint64, index: int32) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Returns the point-index of the mesh given a face-vertex index.


.. py:function:: closest_point_edge_edge(p1: vec3f, q1: vec3f, p2: vec3f, q2: vec3f, epsilon: float32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Finds the closest points between two edges.

    Returns barycentric weights to the points on each edge, as well as the closest distance between the edges.

    :param p1: First point of first edge
    :param q1: Second point of first edge
    :param p2: First point of second edge
    :param q2: Second point of second edge
    :param epsilon: Zero tolerance for determining if points in an edge are degenerate.
    :param out: vec3 output containing (s,t,d), where `s` in [0,1] is the barycentric weight for the first edge, `t` is the barycentric weight for the second edge, and `d` is the distance between the two edges at these two closest points.




Volumes
---------------
.. py:function:: volume_sample(id: uint64, uvw: vec3f, sampling_mode: int32, dtype: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Sample the volume of type `dtype` given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_sample_grad(id: uint64, uvw: vec3f, sampling_mode: int32, grad: Any, dtype: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup(id: uint64, i: int32, j: int32, k: int32, dtype: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Returns the value of voxel with coordinates ``i``, ``j``, ``k`` for a volume of type type `dtype`.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store(id: uint64, i: int32, j: int32, k: int32, value: Any) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_f(id: uint64, uvw: vec3f, sampling_mode: int32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_sample_grad_f(id: uint64, uvw: vec3f, sampling_mode: int32, grad: vec3f) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Sample the volume and its gradient given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup_f(id: uint64, i: int32, j: int32, k: int32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Returns the value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value


.. py:function:: volume_store_f(id: uint64, i: int32, j: int32, k: int32, value: float32) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_v(id: uint64, uvw: vec3f, sampling_mode: int32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Sample the vector volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR.`


.. py:function:: volume_lookup_v(id: uint64, i: int32, j: int32, k: int32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Returns the vector value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store_v(id: uint64, i: int32, j: int32, k: int32, value: vec3f) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_i(id: uint64, uvw: vec3f) -> int

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Sample the :class:`int32` volume given by ``id`` at the volume local-space point ``uvw``. 


.. py:function:: volume_lookup_i(id: uint64, i: int32, j: int32, k: int32) -> int

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Returns the :class:`int32` value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.


.. py:function:: volume_store_i(id: uint64, i: int32, j: int32, k: int32, value: int32) -> None

    .. hlist::
       :columns: 8

       * Kernel

    Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``.


.. py:function:: volume_sample_index(id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and `background` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.
    


.. py:function:: volume_sample_grad_index(id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any, grad: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel
       * Differentiable

    Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and `background` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`wp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.
   


.. py:function:: volume_lookup_index(id: uint64, i: int32, j: int32, k: int32) -> int32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Returns the index associated to the voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns -1.
    This function is available for both index grids and classical volumes.
    


.. py:function:: volume_index_to_world(id: uint64, uvw: vec3f) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Transform a point ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation.


.. py:function:: volume_world_to_index(id: uint64, xyz: vec3f) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Transform a point ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation.


.. py:function:: volume_index_to_world_dir(id: uint64, uvw: vec3f) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Transform a direction ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation.


.. py:function:: volume_world_to_index_dir(id: uint64, xyz: vec3f) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Transform a direction ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation.




Random
---------------
.. py:function:: rand_init(seed: int32) -> uint32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Initialize a new random number generator given a user-defined seed. Returns a 32-bit integer representing the RNG state.


.. py:function:: rand_init(seed: int32, offset: int32) -> uint32
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Initialize a new random number generator given a user-defined seed and an offset.

    This alternative constructor can be useful in parallel programs, where a kernel as a whole should share a seed,
    but each thread should generate uncorrelated values. In this case usage should be ``r = rand_init(seed, tid)``


.. py:function:: randi(state: uint32) -> int

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random integer in the range [-2^31, 2^31).


.. py:function:: randi(state: uint32, low: int32, high: int32) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random integer between [low, high).


.. py:function:: randu(state: uint32) -> uint32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random unsigned integer in the range [0, 2^32).


.. py:function:: randu(state: uint32, low: uint32, high: uint32) -> uint32
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random unsigned integer between [low, high).


.. py:function:: randf(state: uint32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random float between [0.0, 1.0).


.. py:function:: randf(state: uint32, low: float32, high: float32) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Return a random float between [low, high).


.. py:function:: randn(state: uint32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Sample a normal (Gaussian) distribution of mean 0 and variance 1. 


.. py:function:: sample_cdf(state: uint32, cdf: Array[float32]) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Inverse-transform sample a cumulative distribution function.


.. py:function:: sample_triangle(state: uint32) -> vec2f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a triangle. Returns sample barycentric coordinates.


.. py:function:: sample_unit_ring(state: uint32) -> vec2f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a ring in the xy plane.


.. py:function:: sample_unit_disk(state: uint32) -> vec2f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a disk in the xy plane.


.. py:function:: sample_unit_sphere_surface(state: uint32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit sphere surface.


.. py:function:: sample_unit_sphere(state: uint32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit sphere.


.. py:function:: sample_unit_hemisphere_surface(state: uint32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit hemisphere surface.


.. py:function:: sample_unit_hemisphere(state: uint32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit hemisphere.


.. py:function:: sample_unit_square(state: uint32) -> vec2f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit square.


.. py:function:: sample_unit_cube(state: uint32) -> vec3f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Uniformly sample a unit cube.


.. py:function:: poisson(state: uint32, lam: float32) -> uint32

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Generate a random sample from a Poisson distribution.

    :param state: RNG state
    :param lam: The expected value of the distribution


.. py:function:: noise(state: uint32, x: float32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Non-periodic Perlin-style noise in 1D.


.. py:function:: noise(state: uint32, xy: vec2f) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Non-periodic Perlin-style noise in 2D.


.. py:function:: noise(state: uint32, xyz: vec3f) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Non-periodic Perlin-style noise in 3D.


.. py:function:: noise(state: uint32, xyzt: vec4f) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Non-periodic Perlin-style noise in 4D.


.. py:function:: pnoise(state: uint32, x: float32, px: int32) -> float

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Periodic Perlin-style noise in 1D.


.. py:function:: pnoise(state: uint32, xy: vec2f, px: int32, py: int32) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Periodic Perlin-style noise in 2D.


.. py:function:: pnoise(state: uint32, xyz: vec3f, px: int32, py: int32, pz: int32) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Periodic Perlin-style noise in 3D.


.. py:function:: pnoise(state: uint32, xyzt: vec4f, px: int32, py: int32, pz: int32, pt: int32) -> float
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Periodic Perlin-style noise in 4D.


.. py:function:: curlnoise(state: uint32, xy: vec2f, octaves: uint32, lacunarity: float32, gain: float32) -> vec2f

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Divergence-free vector field based on the gradient of a Perlin noise function.


.. py:function:: curlnoise(state: uint32, xyz: vec3f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Divergence-free vector field based on the curl of three Perlin noise functions.


.. py:function:: curlnoise(state: uint32, xyzt: vec4f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Divergence-free vector field based on the curl of three Perlin noise functions.




Other
---------------
.. py:function:: lower_bound(arr: Array[Scalar], value: Scalar) -> int

    .. hlist::
       :columns: 8

       * Kernel

    Search a sorted array ``arr`` for the closest element greater than or equal to ``value``.


.. py:function:: lower_bound(arr: Array[Scalar], arr_begin: int32, arr_end: int32, value: Scalar) -> int
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel

    Search a sorted array ``arr`` in the range [arr_begin, arr_end) for the closest element greater than or equal to ``value``.




Operators
---------------
.. py:function:: add(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: add(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: add(a: Quaternion[Scalar], b: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: add(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: add(a: Transformation[Scalar], b: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: add(a: Tile[Any,Tuple[int, ...]], b: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Add each element of two tiles together


.. py:function:: sub(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: sub(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: sub(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: sub(a: Quaternion[Scalar], b: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: sub(a: Transformation[Scalar], b: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: sub(a: Tile[Any,Tuple[int, ...]], b: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Subtract each element b from a


.. py:function:: bit_and(a: Int, b: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_and(a: Vector[Any,Int], b: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_and(a: Matrix[Any,Any,Int], b: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_and(a: Tile[Any,Tuple[int, ...]], b: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Bitwise AND each element of two tiles together


.. py:function:: bit_or(a: Int, b: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_or(a: Vector[Any,Int], b: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_or(a: Matrix[Any,Any,Int], b: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_or(a: Tile[Any,Tuple[int, ...]], b: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Bitwise OR each element of two tiles together


.. py:function:: bit_xor(a: Int, b: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_xor(a: Vector[Any,Int], b: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_xor(a: Matrix[Any,Any,Int], b: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: bit_xor(a: Tile[Any,Tuple[int, ...]], b: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Bitwise XOR each element of two tiles together


.. py:function:: lshift(a: Int, b: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: lshift(a: Vector[Any,Int], b: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: lshift(a: Matrix[Any,Any,Int], b: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: rshift(a: Int, b: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: rshift(a: Vector[Any,Int], b: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: rshift(a: Matrix[Any,Any,Int], b: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: invert(a: Int) -> Int

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: invert(a: Vector[Any,Int]) -> Vector[Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: invert(a: Matrix[Any,Any,Int]) -> Matrix[Any,Any,Int]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: mul(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Vector[Any,Scalar], b: Scalar) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Scalar, b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Quaternion[Scalar], b: Scalar) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Scalar, b: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Quaternion[Scalar], b: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Scalar, b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Matrix[Any,Any,Scalar], b: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Matrix[Any,Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Vector[Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Matrix[Any,Any,Scalar], b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Transformation[Scalar], b: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Scalar, b: Transformation[Scalar]) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(a: Transformation[Scalar], b: Scalar) -> Transformation[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: mul(x: Tile[Any,Tuple[int, ...]], y: Scalar) -> Tile[Any,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Multiply each element of a tile by a scalar


.. py:function:: mul(x: Scalar, y: Tile[Any,Tuple[int, ...]]) -> Tile[Any,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Multiply each element of a tile by a scalar


.. py:function:: mod(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Modulo operation using truncated division.


.. py:function:: mod(a: Vector[Any,Scalar], b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python

    Modulo operation using truncated division.


.. py:function:: div(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Vector[Any,Scalar], b: Scalar) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Scalar, b: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Matrix[Any,Any,Scalar], b: Scalar) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Scalar, b: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Quaternion[Scalar], b: Scalar) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: div(a: Scalar, b: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: floordiv(a: Scalar, b: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: pos(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: pos(x: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: pos(x: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: pos(x: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: neg(x: Scalar) -> Scalar

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: neg(x: Vector[Any,Scalar]) -> Vector[Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: neg(x: Quaternion[Scalar]) -> Quaternion[Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: neg(x: Matrix[Any,Any,Scalar]) -> Matrix[Any,Any,Scalar]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable


.. py:function:: neg(x: Tile[Any,Tuple[int, ...]]) -> Tile[Scalar,Tuple[int, ...]]
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python
       * Differentiable

    Negate each element of a tile


.. py:function:: unot(a: bool) -> bool

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: int8) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: uint8) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: int16) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: uint16) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: int32) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: uint32) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: int64) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: uint64) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python


.. py:function:: unot(a: Array[Any]) -> bool
    :noindex:
    :nocontentsentry:

    .. hlist::
       :columns: 8

       * Kernel
       * Python




Code Generation
---------------
.. py:function:: static(expr: Any) -> Any

    .. hlist::
       :columns: 8

       * Kernel

    Evaluate a static Python expression and replaces it with its result.

    See the :ref:`code generation guide <static_expressions>` for more details.

    The inner expression must only reference variables that are available from the current scope where the Warp kernel or function containing the expression is defined,
    which includes constant variables and variables captured in the current closure in which the function or kernel is implemented.
    The return type of the expression must be either a Warp function, a string, or a type that is supported inside Warp kernels and functions
    (excluding Warp arrays since they cannot be created in a Warp kernel at the moment).


