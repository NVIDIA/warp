# SPDX-FileCopyrightText: Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Autogenerated file, do not edit, this file provides stubs for builtins autocomplete in VSCode, PyCharm, etc

from collections.abc import Sequence
from typing import Any
from typing import Callable
from typing import TypeVar
from typing import Generic
from typing import Literal
from typing import overload as over

import builtins as _builtins

from warp._src.types import Int as Int
from warp._src.types import Float as Float
from warp._src.types import Scalar as Scalar

Length = TypeVar("Length", bound=int)
Rows = TypeVar("Rows", bound=int)
Cols = TypeVar("Cols", bound=int)
DType = TypeVar("DType")
Shape = TypeVar("Shape")

class Vector(Generic[Length, Scalar]): ...
class Matrix(Generic[Rows, Cols, Scalar]): ...
class Quaternion(Generic[Float]): ...
class Transformation(Generic[Float]): ...
class Array(Generic[DType]): ...
class FabricArray(Generic[DType]): ...
class IndexedFabricArray(Generic[DType]): ...
class Tile(Generic[DType, Shape]): ...

"""The ``warp`` package provides array types and functions for creating and manipulating
multi-dimensional data on CPU and CUDA devices. It includes kernel and function decorators
(:func:`kernel`, :func:`func`) for defining parallel code, along with a comprehensive set
of built-in types and functions for use within kernels (see :doc:`/language_reference/builtins`).

The package provides device management, kernel launch and synchronization functions, automatic
differentiation via :class:`Tape` recording, type introspection and construction utilities, and
module compilation and caching.

Additional functionality is available in optional submodules that must be explicitly
imported, such as :mod:`warp.render` for visualization, :mod:`warp.fem` for finite
element methods, and :mod:`warp.sparse` for sparse linear algebra.
"""

from warp._src.context import DeviceLike as DeviceLike

from warp._src.types import bool as bool
from warp._src.types import int8 as int8
from warp._src.types import uint8 as uint8
from warp._src.types import int16 as int16
from warp._src.types import uint16 as uint16
from warp._src.types import int32 as int32
from warp._src.types import uint32 as uint32
from warp._src.types import int64 as int64
from warp._src.types import uint64 as uint64
from warp._src.types import float16 as float16
from warp._src.types import float32 as float32
from warp._src.types import float64 as float64

from warp._src.types import vec2 as vec2

from warp._src.types import vec3 as vec3

from warp._src.types import vec4 as vec4

from warp._src.types import mat22 as mat22

from warp._src.types import mat33 as mat33

from warp._src.types import mat44 as mat44

from warp._src.types import matrix_from_cols as matrix_from_cols
from warp._src.types import matrix_from_rows as matrix_from_rows

from warp._src.types import quat as quat

from warp._src.types import transform as transform

# Skipped: from warp._src.types import spatial_vector as spatial_vector (kernel builtin stubs preferred)
from warp._src.types import spatial_vectorh as spatial_vectorh
from warp._src.types import spatial_vectorf as spatial_vectorf
from warp._src.types import spatial_vectord as spatial_vectord

from warp._src.types import spatial_matrix as spatial_matrix
from warp._src.types import spatial_matrixh as spatial_matrixh
from warp._src.types import spatial_matrixf as spatial_matrixf
from warp._src.types import spatial_matrixd as spatial_matrixd

from warp._src.types import array as array
from warp._src.types import array1d as array1d
from warp._src.types import array2d as array2d
from warp._src.types import array3d as array3d
from warp._src.types import array4d as array4d

from warp._src.types import fixedarray as fixedarray

# Skipped: from warp._src.types import tile as tile (kernel builtin stubs preferred)

from warp._src.types import from_ptr as from_ptr

# Skipped: from warp._src.context import zeros as zeros (merged stubs generated below)
from warp._src.context import zeros_like as zeros_like
from warp._src.context import ones as ones
from warp._src.context import ones_like as ones_like
from warp._src.context import full as full
from warp._src.context import full_like as full_like
from warp._src.context import clone as clone
from warp._src.context import empty as empty
from warp._src.context import empty_like as empty_like
from warp._src.context import copy as copy

from warp._src.types import indexedarray as indexedarray
from warp._src.types import indexedarray1d as indexedarray1d
from warp._src.types import indexedarray2d as indexedarray2d
from warp._src.types import indexedarray3d as indexedarray3d
from warp._src.types import indexedarray4d as indexedarray4d

from warp._src.types import Bvh as Bvh
from warp._src.types import Mesh as Mesh
from warp._src.types import HashGrid as HashGrid
from warp._src.types import Volume as Volume
from warp._src.types import Texture as Texture
from warp._src.types import Texture2D as Texture2D
from warp._src.types import Texture3D as Texture3D
from warp._src.texture import TextureFilterMode as TextureFilterMode
from warp._src.texture import TextureAddressMode as TextureAddressMode
from warp._src.types import BvhQuery as BvhQuery
from warp._src.types import BvhQueryTiled as BvhQueryTiled
from warp._src.types import HashGridQuery as HashGridQuery
from warp._src.types import MeshQueryAABB as MeshQueryAABB
from warp._src.types import MeshQueryAABBTiled as MeshQueryAABBTiled
from warp._src.types import MeshQueryPoint as MeshQueryPoint
from warp._src.types import MeshQueryRay as MeshQueryRay

from warp._src.context import init as init

from warp._src.context import is_cpu_available as is_cpu_available
from warp._src.context import is_cuda_available as is_cuda_available

from warp._src.build import clear_kernel_cache as clear_kernel_cache
from warp._src.build import clear_lto_cache as clear_lto_cache

from warp._src.codegen import WarpCodegenAttributeError as WarpCodegenAttributeError
from warp._src.codegen import WarpCodegenError as WarpCodegenError
from warp._src.codegen import WarpCodegenIndexError as WarpCodegenIndexError
from warp._src.codegen import WarpCodegenKeyError as WarpCodegenKeyError
from warp._src.codegen import WarpCodegenTypeError as WarpCodegenTypeError
from warp._src.codegen import WarpCodegenValueError as WarpCodegenValueError

from warp._src.context import func as func
from warp._src.context import func_grad as func_grad
from warp._src.context import func_replay as func_replay
from warp._src.context import func_native as func_native
from warp._src.context import grad as grad
from warp._src.context import kernel as kernel
from warp._src.context import struct as struct
from warp._src.context import overload as overload
from warp._src.types import constant as constant
from warp._src.utils import map as map
from warp._src.builtins import static as static

from warp._src.context import Kernel as Kernel
from warp._src.context import Function as Function
from warp._src.context import Launch as Launch
from warp._src.context import Module as Module

from warp._src.context import launch as launch
from warp._src.context import launch_tiled as launch_tiled
from warp._src.context import synchronize as synchronize

from warp._src.tape import Tape as Tape

from warp._src.context import Device as Device
from warp._src.utils import ScopedDevice as ScopedDevice

from warp._src.context import is_device_available as is_device_available

from warp._src.context import get_devices as get_devices
from warp._src.context import get_preferred_device as get_preferred_device
from warp._src.context import get_cuda_devices as get_cuda_devices
from warp._src.context import get_cuda_device_count as get_cuda_device_count
from warp._src.context import get_cuda_device as get_cuda_device
from warp._src.context import get_cuda_supported_archs as get_cuda_supported_archs
from warp._src.context import get_cuda_toolkit_version as get_cuda_toolkit_version
from warp._src.context import get_cuda_driver_version as get_cuda_driver_version

from warp._src.context import map_cuda_device as map_cuda_device
from warp._src.context import unmap_cuda_device as unmap_cuda_device

from warp._src.context import get_device as get_device
from warp._src.context import set_device as set_device

from warp._src.context import synchronize_device as synchronize_device

from warp._src.context import set_module_options as set_module_options
from warp._src.context import get_module_options as get_module_options

from warp._src.context import get_module as get_module
from warp._src.context import force_load as force_load
from warp._src.context import load_module as load_module

from warp._src.context import compile_aot_module as compile_aot_module
from warp._src.context import load_aot_module as load_aot_module

from warp._src.context import Stream as Stream
from warp._src.utils import ScopedStream as ScopedStream

from warp._src.context import get_stream as get_stream
from warp._src.context import set_stream as set_stream
from warp._src.context import wait_stream as wait_stream
from warp._src.context import synchronize_stream as synchronize_stream

from warp._src.context import Event as Event
from warp._src.context import record_event as record_event
from warp._src.context import wait_event as wait_event
from warp._src.context import synchronize_event as synchronize_event
from warp._src.context import get_event_elapsed_time as get_event_elapsed_time

from warp._src.utils import ScopedMempool as ScopedMempool
from warp._src.utils import ScopedMempoolAccess as ScopedMempoolAccess
from warp._src.utils import ScopedPeerAccess as ScopedPeerAccess

from warp._src.context import is_mempool_supported as is_mempool_supported
from warp._src.context import is_mempool_enabled as is_mempool_enabled
from warp._src.context import set_mempool_enabled as set_mempool_enabled

from warp._src.context import set_mempool_release_threshold as set_mempool_release_threshold
from warp._src.context import get_mempool_release_threshold as get_mempool_release_threshold
from warp._src.context import get_mempool_used_mem_current as get_mempool_used_mem_current
from warp._src.context import get_mempool_used_mem_high as get_mempool_used_mem_high

from warp._src.context import is_mempool_access_supported as is_mempool_access_supported
from warp._src.context import is_mempool_access_enabled as is_mempool_access_enabled
from warp._src.context import set_mempool_access_enabled as set_mempool_access_enabled

from warp._src.context import is_peer_access_supported as is_peer_access_supported
from warp._src.context import is_peer_access_enabled as is_peer_access_enabled
from warp._src.context import set_peer_access_enabled as set_peer_access_enabled

from warp._src.utils import ScopedCapture as ScopedCapture

from warp._src.context import is_conditional_graph_supported as is_conditional_graph_supported

from warp._src.context import capture_begin as capture_begin
from warp._src.context import capture_end as capture_end
from warp._src.context import capture_launch as capture_launch
from warp._src.context import capture_if as capture_if
from warp._src.context import capture_while as capture_while
from warp._src.context import capture_debug_dot_print as capture_debug_dot_print

from warp._src.types import from_ipc_handle as from_ipc_handle
from warp._src.context import event_from_ipc_handle as event_from_ipc_handle

from warp._src.utils import ScopedTimer as ScopedTimer

from warp._src.utils import TimingResult as TimingResult
from warp._src.utils import timing_begin as timing_begin
from warp._src.utils import timing_end as timing_end
from warp._src.utils import timing_print as timing_print

from warp._src.utils import TIMING_KERNEL as TIMING_KERNEL
from warp._src.utils import TIMING_KERNEL_BUILTIN as TIMING_KERNEL_BUILTIN
from warp._src.utils import TIMING_MEMCPY as TIMING_MEMCPY
from warp._src.utils import TIMING_MEMSET as TIMING_MEMSET
from warp._src.utils import TIMING_GRAPH as TIMING_GRAPH
from warp._src.utils import TIMING_ALL as TIMING_ALL

from warp._src.types import dtype_from_numpy as dtype_from_numpy
from warp._src.types import dtype_to_numpy as dtype_to_numpy

from warp._src.context import from_numpy as from_numpy

from warp._src.dlpack import from_dlpack as from_dlpack
from warp._src.dlpack import to_dlpack as to_dlpack

from warp._src.jax import from_jax as from_jax
from warp._src.jax import to_jax as to_jax
from warp._src.jax import dtype_from_jax as dtype_from_jax
from warp._src.jax import dtype_to_jax as dtype_to_jax
from warp._src.jax import device_from_jax as device_from_jax
from warp._src.jax import device_to_jax as device_to_jax

from warp._src.torch import from_torch as from_torch
from warp._src.torch import to_torch as to_torch
from warp._src.torch import dtype_from_torch as dtype_from_torch
from warp._src.torch import dtype_to_torch as dtype_to_torch
from warp._src.torch import device_from_torch as device_from_torch
from warp._src.torch import device_to_torch as device_to_torch
from warp._src.torch import stream_from_torch as stream_from_torch
from warp._src.torch import stream_to_torch as stream_to_torch

from warp._src.fabric import fabricarray as fabricarray
from warp._src.fabric import fabricarrayarray as fabricarrayarray
from warp._src.fabric import indexedfabricarray as indexedfabricarray
from warp._src.fabric import indexedfabricarrayarray as indexedfabricarrayarray

from warp._src.paddle import from_paddle as from_paddle
from warp._src.paddle import to_paddle as to_paddle
from warp._src.paddle import dtype_from_paddle as dtype_from_paddle
from warp._src.paddle import dtype_to_paddle as dtype_to_paddle
from warp._src.paddle import device_from_paddle as device_from_paddle
from warp._src.paddle import device_to_paddle as device_to_paddle
from warp._src.paddle import stream_from_paddle as stream_from_paddle

from warp._src.utils import transform_expand as transform_expand

from warp._src.utils import quat_between_vectors as quat_between_vectors

from warp._src.constants import *

from . import config as config
from . import types as types
from . import utils as utils

from warp._src.math import *
from warp._src.marching_cubes import MarchingCubes as MarchingCubes
from warp._src.context import RegisteredGLBuffer as RegisteredGLBuffer

__version__ = config.version

from warp._src import types as _types

def __getattr__(name):
    from warp._src.utils import get_deprecated_api  # noqa: PLC0415

    if name == "mat":
        return get_deprecated_api(_types, "warp", "matrix", old_attr_path="warp.mat")
    elif name == "vec":
        return get_deprecated_api(_types, "warp", "vector", old_attr_path="warp.vec")

    if name in (
        "build_dll",
        "build",
        "builtins",
        "codegen",
        "constants",
        "context",
        "dlpack",
        "fabric",
        "jax",
        "marching_cubes",
        "math",
        "paddle",
        "tape",
        "torch",
        "types",
        "utils",
    ):
        import importlib  # noqa: PLC0415

        return importlib.import_module(f".{name}", __package__)

    raise AttributeError(f"module 'warp' has no attribute '{name}'")

class vec2h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2h) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float16, y: float16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2f) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float32, y: float32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2d) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float64, y: float64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2b:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2b) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int8, y: int8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2ub:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2ub) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint8, y: uint8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2s:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2s) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int16, y: int16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2us:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2us) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint16, y: uint16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2i:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2i) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int32, y: int32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2ui:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2ui) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint32, y: uint32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2l:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2l) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int64, y: int64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec2ul:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec2ul) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint64, y: uint64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3h) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float16, y: float16, z: float16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3f) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float32, y: float32, z: float32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3d) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float64, y: float64, z: float64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3b:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3b) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int8, y: int8, z: int8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3ub:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3ub) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint8, y: uint8, z: uint8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3s:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3s) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int16, y: int16, z: int16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3us:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3us) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint16, y: uint16, z: uint16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3i:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3i) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int32, y: int32, z: int32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3ui:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3ui) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint32, y: uint32, z: uint32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3l:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3l) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int64, y: int64, z: int64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec3ul:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec3ul) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint64, y: uint64, z: uint64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4h) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float16, y: float16, z: float16, w: float16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4f) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float32, y: float32, z: float32, w: float32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4d) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: float64, y: float64, z: float64, w: float64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4b:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4b) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int8, y: int8, z: int8, w: int8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4ub:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4ub) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint8, y: uint8, z: uint8, w: uint8) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint8]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint8) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4s:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4s) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int16, y: int16, z: int16, w: int16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4us:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4us) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint16, y: uint16, z: uint16, w: uint16) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint16]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint16) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4i:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4i) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int32, y: int32, z: int32, w: int32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4ui:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4ui) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint32, y: uint32, z: uint32, w: uint32) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint32]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint32) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4l:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4l) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: int64, y: int64, z: int64, w: int64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[int64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: int64) -> None:
        """Construct a vector filled with a value."""
        ...

class vec4ul:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized vector."""
        ...

    @over
    def __init__(self, other: vec4ul) -> None:
        """Construct a vector by copy."""
        ...

    @over
    def __init__(self, x: uint64, y: uint64, z: uint64, w: uint64) -> None:
        """Construct a vector from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[uint64]) -> None:
        """Construct a vector from a sequence of values."""
        ...

    @over
    def __init__(self, value: uint64) -> None:
        """Construct a vector filled with a value."""
        ...

class mat22h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat22h) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(self, m00: float16, m01: float16, m10: float16, m11: float16) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec2h, v1: vec2h) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat22f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat22f) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(self, m00: float32, m01: float32, m10: float32, m11: float32) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec2f, v1: vec2f) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat22d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat22d) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(self, m00: float64, m01: float64, m10: float64, m11: float64) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec2d, v1: vec2d) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat33h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat33h) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float16,
        m01: float16,
        m02: float16,
        m10: float16,
        m11: float16,
        m12: float16,
        m20: float16,
        m21: float16,
        m22: float16,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec3h, v1: vec3h, v2: vec3h) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat33f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat33f) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float32,
        m01: float32,
        m02: float32,
        m10: float32,
        m11: float32,
        m12: float32,
        m20: float32,
        m21: float32,
        m22: float32,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec3f, v1: vec3f, v2: vec3f) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat33d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat33d) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float64,
        m01: float64,
        m02: float64,
        m10: float64,
        m11: float64,
        m12: float64,
        m20: float64,
        m21: float64,
        m22: float64,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec3d, v1: vec3d, v2: vec3d) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat44h:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat44h) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float16,
        m01: float16,
        m02: float16,
        m03: float16,
        m10: float16,
        m11: float16,
        m12: float16,
        m13: float16,
        m20: float16,
        m21: float16,
        m22: float16,
        m23: float16,
        m30: float16,
        m31: float16,
        m32: float16,
        m33: float16,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec4h, v1: vec4h, v2: vec4h, v3: vec4h) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat44f:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat44f) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float32,
        m01: float32,
        m02: float32,
        m03: float32,
        m10: float32,
        m11: float32,
        m12: float32,
        m13: float32,
        m20: float32,
        m21: float32,
        m22: float32,
        m23: float32,
        m30: float32,
        m31: float32,
        m32: float32,
        m33: float32,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec4f, v1: vec4f, v2: vec4f, v3: vec4f) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a matrix filled with a value."""
        ...

class mat44d:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized matrix."""
        ...

    @over
    def __init__(self, other: mat44d) -> None:
        """Construct a matrix by copy."""
        ...

    @over
    def __init__(
        self,
        m00: float64,
        m01: float64,
        m02: float64,
        m03: float64,
        m10: float64,
        m11: float64,
        m12: float64,
        m13: float64,
        m20: float64,
        m21: float64,
        m22: float64,
        m23: float64,
        m30: float64,
        m31: float64,
        m32: float64,
        m33: float64,
    ) -> None:
        """Construct a matrix from its component values."""
        ...

    @over
    def __init__(self, v0: vec4d, v1: vec4d, v2: vec4d, v3: vec4d) -> None:
        """Construct a matrix from its row vectors."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a matrix from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a matrix filled with a value."""
        ...

class quath:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized quaternion."""
        ...

    @over
    def __init__(self, other: quath) -> None:
        """Construct a quaternion by copy."""
        ...

    @over
    def __init__(self, x: float16, y: float16, z: float16, w: float16) -> None:
        """Construct a quaternion from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float16]) -> None:
        """Construct a quaternion from a sequence of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a quaternion filled with a value."""
        ...

class quatf:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized quaternion."""
        ...

    @over
    def __init__(self, other: quatf) -> None:
        """Construct a quaternion by copy."""
        ...

    @over
    def __init__(self, x: float32, y: float32, z: float32, w: float32) -> None:
        """Construct a quaternion from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float32]) -> None:
        """Construct a quaternion from a sequence of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a quaternion filled with a value."""
        ...

class quatd:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized quaternion."""
        ...

    @over
    def __init__(self, other: quatd) -> None:
        """Construct a quaternion by copy."""
        ...

    @over
    def __init__(self, x: float64, y: float64, z: float64, w: float64) -> None:
        """Construct a quaternion from its component values."""
        ...

    @over
    def __init__(self, args: Sequence[float64]) -> None:
        """Construct a quaternion from a sequence of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a quaternion filled with a value."""
        ...

class transformh:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized transformation."""
        ...

    @over
    def __init__(self, other: transformh) -> None:
        """Construct a transformation by copy."""
        ...

    @over
    def __init__(self, p: vec3h, q: quath) -> None:
        """Construct a transformation from its p and q components."""
        ...

    @over
    def __init__(
        self, px: float16, py: float16, pz: float16, qx: float16, qy: float16, qz: float16, qw: float16
    ) -> None:
        """Construct a transformation from its component values."""
        ...

    @over
    def __init__(self, p: Sequence[float16], q: Sequence[float16]) -> None:
        """Construct a transformation from two sequences of values."""
        ...

    @over
    def __init__(self, value: float16) -> None:
        """Construct a transformation filled with a value."""
        ...

class transformf:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized transformation."""
        ...

    @over
    def __init__(self, other: transformf) -> None:
        """Construct a transformation by copy."""
        ...

    @over
    def __init__(self, p: vec3f, q: quatf) -> None:
        """Construct a transformation from its p and q components."""
        ...

    @over
    def __init__(
        self, px: float32, py: float32, pz: float32, qx: float32, qy: float32, qz: float32, qw: float32
    ) -> None:
        """Construct a transformation from its component values."""
        ...

    @over
    def __init__(self, p: Sequence[float32], q: Sequence[float32]) -> None:
        """Construct a transformation from two sequences of values."""
        ...

    @over
    def __init__(self, value: float32) -> None:
        """Construct a transformation filled with a value."""
        ...

class transformd:
    @over
    def __init__(self) -> None:
        """Construct a zero-initialized transformation."""
        ...

    @over
    def __init__(self, other: transformd) -> None:
        """Construct a transformation by copy."""
        ...

    @over
    def __init__(self, p: vec3d, q: quatd) -> None:
        """Construct a transformation from its p and q components."""
        ...

    @over
    def __init__(
        self, px: float64, py: float64, pz: float64, qx: float64, qy: float64, qz: float64, qw: float64
    ) -> None:
        """Construct a transformation from its component values."""
        ...

    @over
    def __init__(self, p: Sequence[float64], q: Sequence[float64]) -> None:
        """Construct a transformation from two sequences of values."""
        ...

    @over
    def __init__(self, value: float64) -> None:
        """Construct a transformation filled with a value."""
        ...

# ======================================================================
# Merged stubs for symbols with both Python API and kernel-scope versions
# ======================================================================

@over
def zeros(
    shape: int | tuple[int, ...] | list[int] | None = None,
    dtype: type = float,
    device: DeviceLike = None,
    requires_grad: _builtins.bool = False,
    pinned: _builtins.bool = False,
    **kwargs,
) -> array:
    """Return a zero-initialized array."""
    ...

@over
def zeros(shape: tuple[int, ...], dtype: Any) -> Array[Scalar]:
    """Create a zero-initialized fixed-size array of the given shape and dtype."""
    ...

@over
def zeros(shape: int32, dtype: Any) -> Array[Scalar]:
    """Create a zero-initialized fixed-size array of the given length and dtype."""
    ...

@over
def min(a: Scalar, b: Scalar) -> Scalar:
    """Compute the minimum value."""
    ...

@over
def min(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Compute the minimum value.

    Returns:
        The element-wise minimum of ``a`` and ``b``.
    """
    ...

@over
def min(a: Vector[Any, Scalar]) -> Scalar:
    """Compute the minimum value.

    Returns:
        The minimum element of ``a``.
    """
    ...

@over
def max(a: Scalar, b: Scalar) -> Scalar:
    """Compute the maximum value."""
    ...

@over
def max(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Compute the maximum value.

    Returns:
        The element-wise maximum of ``a`` and ``b``.
    """
    ...

@over
def max(a: Vector[Any, Scalar]) -> Scalar:
    """Compute the maximum value.

    Returns:
        The maximum element of ``a``.
    """
    ...

def clamp(x: Scalar, low: Scalar, high: Scalar) -> Scalar:
    """Clamp the value of ``x`` to the range [low, high]."""
    ...

@over
def abs(x: Scalar) -> Scalar:
    """Compute the absolute value of ``x``."""
    ...

@over
def abs(x: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Compute the absolute value of ``x``.

    Returns:
        The element-wise absolute value of ``x``.
    """
    ...

@over
def sign(x: Scalar) -> Scalar:
    """Compute the sign of ``x``.

    Returns:
        -1 if ``x`` < 0 and 1 otherwise.
    """
    ...

@over
def sign(x: Vector[Any, Scalar]) -> Scalar:
    """Compute the sign of ``x``.

    Returns:
        -1 for negative elements of ``x`` and 1 otherwise.
    """
    ...

def step(x: Scalar) -> Scalar:
    """Compute 1.0 if ``x`` < 0.0, otherwise 0.0."""
    ...

def nonzero(x: Scalar) -> Scalar:
    """Compute 1.0 if ``x`` is not equal to zero, otherwise 0.0."""
    ...

def sin(x: Float) -> Float:
    """Compute the sine of ``x`` in radians."""
    ...

def cos(x: Float) -> Float:
    """Compute the cosine of ``x`` in radians."""
    ...

def acos(x: Float) -> Float:
    """Compute arccos of ``x`` in radians.

    Inputs are automatically clamped to [-1.0, 1.0].
    """
    ...

def asin(x: Float) -> Float:
    """Compute arcsin of ``x`` in radians.

    Inputs are automatically clamped to [-1.0, 1.0].
    """
    ...

def sqrt(x: Float) -> Float:
    """Compute the square root of ``x``, where ``x`` is positive."""
    ...

def cbrt(x: Float) -> Float:
    """Compute the cube root of ``x``."""
    ...

def tan(x: Float) -> Float:
    """Compute the tangent of ``x`` in radians."""
    ...

def atan(x: Float) -> Float:
    """Compute the arctangent of ``x`` in radians."""
    ...

def atan2(y: Float, x: Float) -> Float:
    """Compute the 2-argument arctangent, atan2, of the point ``(x, y)`` in radians."""
    ...

def sinh(x: Float) -> Float:
    """Compute the sinh of ``x``."""
    ...

def cosh(x: Float) -> Float:
    """Compute the cosh of ``x``."""
    ...

def tanh(x: Float) -> Float:
    """Compute the tanh of ``x``."""
    ...

def degrees(x: Float) -> Float:
    """Convert ``x`` from radians into degrees."""
    ...

def radians(x: Float) -> Float:
    """Convert ``x`` from degrees into radians."""
    ...

def log(x: Float) -> Float:
    """Compute the natural logarithm (base-e) of ``x``, where ``x`` is positive."""
    ...

def log2(x: Float) -> Float:
    """Compute the binary logarithm (base-2) of ``x``, where ``x`` is positive."""
    ...

def log10(x: Float) -> Float:
    """Compute the common logarithm (base-10) of ``x``, where ``x`` is positive."""
    ...

def exp(x: Float) -> Float:
    """Compute the value of the exponential function :math:`e^x`."""
    ...

def pow(x: Float, y: Float) -> Float:
    """Compute ``x`` raised to the power of ``y``."""
    ...

def erf(x: Float) -> Float:
    """Compute the error function of ``x``."""
    ...

def erfc(x: Float) -> Float:
    """Compute the complementary error function of ``x``."""
    ...

def erfinv(x: Float) -> Float:
    """Compute the inverse error function of ``x``."""
    ...

def erfcinv(x: Float) -> Float:
    """Compute the inverse complementary error function of ``x``."""
    ...

def round(x: Float) -> Float:
    """Compute the nearest integer value to ``x``, rounding halfway cases away from zero.

    This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like
    :func:`~warp._src.lang.rint`.
    Differs from :func:`numpy.round`, which behaves the same way as :func:`numpy.rint`.
    """
    ...

def rint(x: Float) -> Float:
    """Compute the nearest integer value to ``x``, rounding halfway cases to nearest even integer.

    It is generally faster than :func:`~warp._src.lang.round`.
    Equivalent to :func:`numpy.rint`.
    """
    ...

def trunc(x: Float) -> Float:
    """Compute the nearest integer that is closer to zero than ``x``.

    In other words, it discards the fractional part of ``x``.
    It is similar to casting ``float(int(a))``, but preserves the negative sign when ``x`` is in the range [-0.0, -1.0).
    Equivalent to :func:`numpy.trunc` and :func:`numpy.fix`.
    """
    ...

def floor(x: Float) -> Float:
    """Compute the largest integer that is less than or equal to ``x``."""
    ...

def ceil(x: Float) -> Float:
    """Compute the smallest integer that is greater than or equal to ``x``."""
    ...

def frac(x: Float) -> Float:
    """Retrieve the fractional part of ``x``.

    In other words, it discards the integer part of ``x`` and is equivalent to ``x - trunc(x)``.
    """
    ...

@over
def isfinite(a: Scalar) -> bool:
    """Check if all elements of ``a`` are finite.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isfinite(a: Vector[Any, Scalar]) -> bool:
    """Check if all elements of ``a`` are finite.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isfinite(a: Quaternion[Float]) -> bool:
    """Check if all elements of ``a`` are finite.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isfinite(a: Matrix[Any, Any, Scalar]) -> bool:
    """Check if all elements of ``a`` are finite.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isnan(a: Scalar) -> bool:
    """Check if any element of ``a`` is NaN.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isnan(a: Vector[Any, Scalar]) -> bool:
    """Check if any element of ``a`` is NaN.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isnan(a: Quaternion[Float]) -> bool:
    """Check if any element of ``a`` is NaN.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isnan(a: Matrix[Any, Any, Scalar]) -> bool:
    """Check if any element of ``a`` is NaN.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isinf(a: Scalar) -> bool:
    """Check if any element of ``a`` is positive or negative infinity.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isinf(a: Vector[Any, Scalar]) -> bool:
    """Check if any element of ``a`` is positive or negative infinity.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isinf(a: Quaternion[Float]) -> bool:
    """Check if any element of ``a`` is positive or negative infinity.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def isinf(a: Matrix[Any, Any, Scalar]) -> bool:
    """Check if any element of ``a`` is positive or negative infinity.

    .. attention:: This function will no longer support integer types as input. Please use float types instead.

    """
    ...

@over
def dot(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Scalar:
    """Compute the dot product."""
    ...

@over
def dot(a: Quaternion[Float], b: Quaternion[Float]) -> Float:
    """Compute the dot product."""
    ...

def ddot(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Scalar:
    """Compute the double dot product between two matrices."""
    ...

def argmin(a: Vector[Any, Scalar]) -> uint32:
    """Compute the index of the minimum element of vector ``a``."""
    ...

def argmax(a: Vector[Any, Scalar]) -> uint32:
    """Compute the index of the maximum element of vector ``a``."""
    ...

def outer(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Compute the outer product ``a*b^T`` for two vectors."""
    ...

def cross(a: Vector[Literal[3], Scalar], b: Vector[Literal[3], Scalar]) -> Vector[Literal[3], Scalar]:
    """Compute the cross product of two 3D vectors."""
    ...

def skew(vec: Vector[Literal[3], Scalar]) -> Matrix[Literal[3], Literal[3], Scalar]:
    """Compute the skew-symmetric 3x3 matrix for a 3D vector ``vec``."""
    ...

@over
def length(a: Vector[Any, Float]) -> Float:
    """Compute the length of ``a``.

    Compute the length of a floating-point vector.
    """
    ...

@over
def length(a: Quaternion[Float]) -> Float:
    """Compute the length of ``a``.

    Compute the length of a quaternion.
    """
    ...

@over
def length_sq(a: Vector[Any, Scalar]) -> Scalar:
    """Compute the squared length of ``a``.

    Compute the squared length of a vector.
    """
    ...

@over
def length_sq(a: Quaternion[Float]) -> Float:
    """Compute the squared length of ``a``.

    Compute the squared length of a quaternion.
    """
    ...

@over
def normalize(a: Vector[Any, Float]) -> Vector[Any, Float]:
    """Compute the normalized value of ``a``.

    If ``length(a)`` is 0, the zero vector is returned.
    """
    ...

@over
def normalize(a: Quaternion[Float]) -> Quaternion[Float]:
    """Compute the normalized value of ``a``.

    If ``length(a)`` is 0, the zero quaternion is returned.
    """
    ...

def transpose(a: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Compute the transpose of matrix ``a``."""
    ...

@over
def inverse(a: Matrix[Literal[2], Literal[2], Float]) -> Matrix[Any, Any, Float]:
    """Compute the inverse of matrix ``a``."""
    ...

@over
def inverse(a: Matrix[Literal[3], Literal[3], Float]) -> Matrix[Any, Any, Float]:
    """Compute the inverse of matrix ``a``."""
    ...

@over
def inverse(a: Matrix[Literal[4], Literal[4], Float]) -> Matrix[Any, Any, Float]:
    """Compute the inverse of matrix ``a``."""
    ...

@over
def determinant(a: Matrix[Literal[2], Literal[2], Float]) -> Float:
    """Compute the determinant of matrix ``a``."""
    ...

@over
def determinant(a: Matrix[Literal[3], Literal[3], Float]) -> Float:
    """Compute the determinant of matrix ``a``."""
    ...

@over
def determinant(a: Matrix[Literal[4], Literal[4], Float]) -> Float:
    """Compute the determinant of matrix ``a``."""
    ...

def trace(a: Matrix[Any, Any, Scalar]) -> Scalar:
    """Compute the trace of matrix ``a``."""
    ...

def diag(vec: Vector[Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Construct a matrix with the components of vector ``vec`` on the diagonal."""
    ...

def get_diag(mat: Matrix[Any, Any, Scalar]) -> Vector[Any, Scalar]:
    """Extract a vector containing the diagonal elements of square matrix ``mat``."""
    ...

@over
def cw_mul(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Compute the component-wise product of ``a`` and ``b``."""
    ...

@over
def cw_mul(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Compute the component-wise product of ``a`` and ``b``."""
    ...

@over
def cw_div(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Compute the component-wise division of ``a`` by ``b``."""
    ...

@over
def cw_div(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Compute the component-wise division of ``a`` by ``b``."""
    ...

def vector(*args: Scalar, length: int32, dtype: Scalar) -> Vector[Any, Scalar]:
    """Construct a vector of given length and dtype.

    If no arguments are given, the vector is zero-initialized.
    """
    ...

@over
def matrix(
    pos: Vector[Literal[3], Float], rot: Quaternion[Float], scale: Vector[Literal[3], Float], dtype: Float
) -> Matrix[Literal[4], Literal[4], Float]:
    """Construct a matrix.

    Construct a 4x4 transformation matrix that applies the transformations as
    ``Translation(pos)*Rotation(rot)*Scaling(scale)`` when applied to column vectors, i.e.: ``y = (TRS)*x``.

    .. versionremoved:: 1.10
        This function has been removed in favor of :func:`~warp._src.lang.transform_compose`.

    .. deprecated:: 1.8
    """
    ...

@over
def matrix(*args: Scalar, shape: tuple[int, int], dtype: Scalar) -> Matrix[Any, Any, Scalar]:
    """Construct a matrix.

    Construct a matrix with the given shape and dtype.

    If no positional arguments are given, the matrix is zero-initialized.
    """
    ...

def identity(n: int32, dtype: Scalar) -> Matrix[Any, Any, Scalar]:
    """Create an identity matrix with shape=(n,n) with the type given by ``dtype``."""
    ...

@over
def svd3(
    A: Matrix[Literal[3], Literal[3], Float],
) -> tuple[Matrix[Literal[3], Literal[3], Float], Vector[Literal[3], Float], Matrix[Literal[3], Literal[3], Float]]:
    """Compute the SVD of a 3x3 matrix ``A``.

    The singular values are returned in ``sigma``, while the left and right basis vectors are returned in ``U`` and ``V``.
    """
    ...

@over
def svd3(
    A: Matrix[Literal[3], Literal[3], Float],
    U: Matrix[Literal[3], Literal[3], Float],
    sigma: Vector[Literal[3], Float],
    V: Matrix[Literal[3], Literal[3], Float],
) -> None:
    """Compute the SVD of a 3x3 matrix ``A``.

    The singular values are returned in ``sigma``, while the left and right basis vectors are returned in ``U`` and ``V``.
    """
    ...

@over
def svd2(
    A: Matrix[Literal[2], Literal[2], Float],
) -> tuple[Matrix[Literal[2], Literal[2], Float], Vector[Literal[2], Float], Matrix[Literal[2], Literal[2], Float]]:
    """Compute the SVD of a 2x2 matrix ``A``.

    The singular values are returned in ``sigma``, while the left and right basis vectors are returned in ``U`` and ``V``.
    """
    ...

@over
def svd2(
    A: Matrix[Literal[2], Literal[2], Float],
    U: Matrix[Literal[2], Literal[2], Float],
    sigma: Vector[Literal[2], Float],
    V: Matrix[Literal[2], Literal[2], Float],
) -> None:
    """Compute the SVD of a 2x2 matrix ``A``.

    The singular values are returned in ``sigma``, while the left and right basis vectors are returned in ``U`` and ``V``.
    """
    ...

@over
def qr3(
    A: Matrix[Literal[3], Literal[3], Float],
) -> tuple[Matrix[Literal[3], Literal[3], Float], Matrix[Literal[3], Literal[3], Float]]:
    """Compute the QR decomposition of a 3x3 matrix ``A``.

    The orthogonal matrix is returned in ``Q``, while the upper triangular matrix is returned in ``R``.
    """
    ...

@over
def qr3(
    A: Matrix[Literal[3], Literal[3], Float],
    Q: Matrix[Literal[3], Literal[3], Float],
    R: Matrix[Literal[3], Literal[3], Float],
) -> None:
    """Compute the QR decomposition of a 3x3 matrix ``A``.

    The orthogonal matrix is returned in ``Q``, while the upper triangular matrix is returned in ``R``.
    """
    ...

@over
def eig3(
    A: Matrix[Literal[3], Literal[3], Float],
) -> tuple[Matrix[Literal[3], Literal[3], Float], Vector[Literal[3], Float]]:
    """Compute the eigendecomposition of a 3x3 matrix ``A``.

    The eigenvectors are returned as the columns of ``Q``, while the corresponding eigenvalues are returned in ``d``.
    """
    ...

@over
def eig3(
    A: Matrix[Literal[3], Literal[3], Float], Q: Matrix[Literal[3], Literal[3], Float], d: Vector[Literal[3], Float]
) -> None:
    """Compute the eigendecomposition of a 3x3 matrix ``A``.

    The eigenvectors are returned as the columns of ``Q``, while the corresponding eigenvalues are returned in ``d``.
    """
    ...

@over
def quaternion(dtype: Float) -> Quaternion[Float]:
    """Construct a quaternion.

    Zero-initialize the quaternion. Quaternions are laid out as
    ``[ix, iy, iz, r]``, where ``ix``, ``iy``, ``iz`` are the imaginary part, and ``r`` the real part.
    """
    ...

@over
def quaternion(x: Float, y: Float, z: Float, w: Float, dtype: Scalar) -> Quaternion[Float]:
    """Construct a quaternion.

    Use the supplied components (type inferred from component type).
    """
    ...

@over
def quaternion(ijk: Vector[Literal[3], Float], real: Float, dtype: Float) -> Quaternion[Float]:
    """Construct a quaternion.

    Use the supplied vector/scalar (type inferred from scalar type).
    """
    ...

@over
def quaternion(quat: Quaternion[Float], dtype: Float) -> Quaternion[Float]:
    """Construct a quaternion.

    Convert ``quat`` to the specified ``dtype``.
    """
    ...

def quat_identity(dtype: Float) -> quatf:
    """Construct an identity quaternion with zero imaginary part and real part of 1.0."""
    ...

def quat_from_axis_angle(axis: Vector[Literal[3], Float], angle: Float) -> Quaternion[Float]:
    """Construct a quaternion representing a rotation of angle radians around the given axis."""
    ...

@over
def quat_to_axis_angle(quat: Quaternion[Float]) -> tuple[Vector[Literal[3], Float], Float]:
    """Extract the rotation axis and angle radians a quaternion represents."""
    ...

@over
def quat_to_axis_angle(quat: Quaternion[Float], axis: Vector[Literal[3], Float], angle: Float) -> None:
    """Extract the rotation axis and angle radians a quaternion represents."""
    ...

@over
def quat_from_matrix(mat: Matrix[Literal[3], Literal[3], Float]) -> Quaternion[Float]:
    """Construct a quaternion from a matrix.

    If the matrix is not a pure rotation, but for example includes scaling or skewing, the result is undefined.
    """
    ...

@over
def quat_from_matrix(mat: Matrix[Literal[4], Literal[4], Float]) -> Quaternion[Float]:
    """Construct a quaternion from a matrix.

    If the top-left 3x3 block of the matrix is not a pure rotation, but for example includes scaling or skewing, the result is undefined.
    """
    ...

def quat_rpy(roll: Float, pitch: Float, yaw: Float) -> Quaternion[Float]:
    """Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians."""
    ...

def quat_inverse(quat: Quaternion[Float]) -> Quaternion[Float]:
    """Compute quaternion conjugate."""
    ...

def quat_rotate(quat: Quaternion[Float], vec: Vector[Literal[3], Float]) -> Vector[Literal[3], Float]:
    """Rotate a vector by a quaternion."""
    ...

def quat_rotate_inv(quat: Quaternion[Float], vec: Vector[Literal[3], Float]) -> Vector[Literal[3], Float]:
    """Rotate a vector by the inverse of a quaternion."""
    ...

def quat_slerp(a: Quaternion[Float], b: Quaternion[Float], t: Float) -> Quaternion[Float]:
    """Linearly interpolate between two quaternions."""
    ...

def quat_to_matrix(quat: Quaternion[Float]) -> Matrix[Literal[3], Literal[3], Float]:
    """Convert a quaternion to a 3x3 rotation matrix."""
    ...

@over
def transformation(p: Vector[Literal[3], Float], q: Quaternion[Float], dtype: Float) -> Transformation[Float]:
    """Construct a transformation.

    Use translation ``p`` and rotation ``q``.
    """
    ...

@over
def transformation(*args: Float, dtype: Float) -> Transformation[Float]:
    """Construct a transformation.

    Build a spatial transform vector from components.
    """
    ...

def transform_identity(dtype: Float) -> transformf:
    """Construct an identity transform with zero translation and identity rotation."""
    ...

def transform_get_translation(xform: Transformation[Float]) -> Vector[Literal[3], Float]:
    """Extract the translational part of transform ``xform``."""
    ...

def transform_get_rotation(xform: Transformation[Float]) -> Quaternion[Float]:
    """Extract the rotational part of transform ``xform``."""
    ...

def transform_set_translation(xform: Transformation[Float], p: Vector[Literal[3], Float]) -> None:
    """Set the translational part of a transform ``xform``."""
    ...

def transform_set_rotation(xform: Transformation[Float], q: Quaternion[Float]) -> None:
    """Set the rotational part of a transform ``xform``."""
    ...

def transform_multiply(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]:
    """Multiply two rigid body transformations together."""
    ...

@over
def transform_point(xform: Transformation[Float], point: Vector[Literal[3], Float]) -> Vector[Literal[3], Float]:
    """Apply a transform to a point.

    Treat the homogeneous coordinate as w=1 (translation and rotation).
    """
    ...

@over
def transform_point(
    mat: Matrix[Literal[4], Literal[4], Float], point: Vector[Literal[3], Float]
) -> Vector[Literal[3], Float]:
    """Apply a transform to a point.

    Treat the homogeneous coordinate as w=1.

    The transformation is applied treating ``point`` as a column vector, e.g.: ``y = mat*point``.

    This is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = point^T*mat^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.
    """
    ...

@over
def transform_vector(xform: Transformation[Float], vec: Vector[Literal[3], Float]) -> Vector[Literal[3], Float]:
    """Apply a transform to a vector.

    Treat the homogeneous coordinate as w=0 (rotation only).
    """
    ...

@over
def transform_vector(
    mat: Matrix[Literal[4], Literal[4], Float], vec: Vector[Literal[3], Float]
) -> Vector[Literal[3], Float]:
    """Apply a transform to a vector.

    Treat the homogeneous coordinate as w=0.

    The transformation is applied treating ``vec`` as a column vector, e.g.: ``y = mat*vec``.

    This is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = vec^T*mat^T``.
    If the transform is coming from a library that uses row-vectors, then users should transpose the transformation
    matrix before calling this method.
    """
    ...

def transform_inverse(xform: Transformation[Float]) -> Transformation[Float]:
    """Compute the inverse of the transformation ``xform``."""
    ...

@over
def spatial_vector(dtype: Float) -> Vector[Literal[6], Float]:
    """Construct a 6D screw vector.

    Zero-initialize the vector.
    """
    ...

@over
def spatial_vector(
    w: Vector[Literal[3], Float], v: Vector[Literal[3], Float], dtype: Float
) -> Vector[Literal[6], Float]:
    """Construct a 6D screw vector.

    Use two 3D vectors.
    """
    ...

@over
def spatial_vector(
    wx: Float, wy: Float, wz: Float, vx: Float, vy: Float, vz: Float, dtype: Float
) -> Vector[Literal[6], Float]:
    """Construct a 6D screw vector.

    Use six scalar values.
    """
    ...

def spatial_adjoint(
    r: Matrix[Literal[3], Literal[3], Float], s: Matrix[Literal[3], Literal[3], Float]
) -> Matrix[Literal[6], Literal[6], Float]:
    """Construct a 6x6 spatial inertial matrix from two 3x3 diagonal blocks."""
    ...

def spatial_dot(a: Vector[Literal[6], Float], b: Vector[Literal[6], Float]) -> Float:
    """Compute the dot product of two 6D screw vectors."""
    ...

def spatial_cross(a: Vector[Literal[6], Float], b: Vector[Literal[6], Float]) -> Vector[Literal[6], Float]:
    """Compute the cross product of two 6D screw vectors."""
    ...

def spatial_cross_dual(a: Vector[Literal[6], Float], b: Vector[Literal[6], Float]) -> Vector[Literal[6], Float]:
    """Compute the dual cross product of two 6D screw vectors."""
    ...

def spatial_top(svec: Vector[Literal[6], Float]) -> Vector[Literal[3], Float]:
    """Extract the top (first) part of a 6D screw vector."""
    ...

def spatial_bottom(svec: Vector[Literal[6], Float]) -> Vector[Literal[3], Float]:
    """Extract the bottom (second) part of a 6D screw vector."""
    ...

def spatial_jacobian(
    S: Array[Vector[Literal[6], Float]],
    joint_parents: Array[int32],
    joint_qd_start: Array[int32],
    joint_start: int32,
    joint_count: int32,
    J_start: int32,
    J_out: Array[Float],
) -> None:
    """Compute the spatial Jacobian matrix for a kinematic chain."""
    ...

def spatial_mass(
    I_s: Array[Matrix[Literal[6], Literal[6], Float]],
    joint_start: int32,
    joint_count: int32,
    M_start: int32,
    M: Array[Float],
) -> None:
    """Compute the composite rigid-body mass matrix for a kinematic chain."""
    ...

@over
def tile_zeros(shape: tuple[int, ...], dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile of zero-initialized items.

    Args:
        shape: Shape of the output tile
        dtype: Data type of output tile's elements (default float)
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A zero-initialized tile with shape and data type as specified.
    """
    ...

@over
def tile_zeros(shape: int32, dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile of zero-initialized items."""
    ...

@over
def tile_ones(shape: tuple[int, ...], dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile of one-initialized items.

    Args:
        shape: Shape of the output tile
        dtype: Data type of output tile's elements
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A one-initialized tile with shape and data type as specified.
    """
    ...

@over
def tile_ones(shape: int32, dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile of one-initialized items."""
    ...

@over
def tile_full(shape: tuple[int, ...], value: Any, dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile filled with the specified value.

    Args:
        shape: Shape of the output tile
        value: Value to fill the tile with
        dtype: Data type of output tile's elements
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile filled with the specified value.
    """
    ...

@over
def tile_full(shape: int32, value: Any, dtype: Any, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Allocate a tile filled with the specified value."""
    ...

@over
def tile_randi(shape: tuple[int, ...], rng: uint32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random integers.

    Args:
        shape: Shape of the output tile
        rng: Random number generator state, typically from :func:`~warp._src.lang.rand_init`
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile of random integers with the specified shape.

    Example:

        .. testcode::

            TILE_M, TILE_N = 2, 2
            M, N = 2, 2
            seed = 42

            @wp.kernel
            def rand_kernel(seed: int, x: wp.array2d(dtype=int)):
                i, j = wp.tid()
                rng = wp.rand_init(seed, i * TILE_M + j)
                t = wp.tile_randi(shape=(TILE_M, TILE_N), rng=rng)
                wp.tile_store(x, t, offset=(i * TILE_M, j * TILE_N))

            x = wp.zeros(shape=(M * TILE_M, N * TILE_N), dtype=int)
            wp.launch_tiled(rand_kernel, dim=[M, N], inputs=[seed, x], block_dim=32)
            print(x.numpy())

        .. testoutput::

            [[  798497746  1803297529  -955788638    17806966]
             [ 1788185933  1320194893  2073257406 -2009156320]
             [ -257534450 -1138585923  1145322783  -321794125]
             [-2096177388 -1835610841  1159339128  -652221052]]

    """
    ...

@over
def tile_randi(shape: int32, rng: uint32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random integers."""
    ...

@over
def tile_randi(shape: tuple[int, ...], rng: uint32, min: int32, max: int32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random integers.

    Sample values in the range [min, max).

    Args:
        shape: Shape of the output tile
        rng: Random number generator state, typically from :func:`~warp._src.lang.rand_init`
        min: Minimum value (inclusive) for random integers
        max: Maximum value (exclusive) for random integers
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile of random integers in the range [min, max) with the specified shape.

    Example:

        .. testcode::

            TILE_M, TILE_N = 2, 2
            M, N = 2, 2
            seed = 42

            @wp.kernel
            def rand_range_kernel(seed: int, x: wp.array2d(dtype=int)):
                i, j = wp.tid()
                rng = wp.rand_init(seed, i * TILE_M + j)
                t = wp.tile_randi(shape=(TILE_M, TILE_N), rng=rng, min=-5, max=5)
                wp.tile_store(x, t, offset=(i * TILE_M, j * TILE_N))

            x = wp.zeros(shape=(M * TILE_M, N * TILE_N), dtype=int)
            wp.launch_tiled(rand_range_kernel, dim=[M, N], inputs=[seed, x], block_dim=32)
            print(x.numpy())

        .. testoutput::

            [[ 1  4  3  1]
             [-2 -2  1  1]
             [ 1 -2 -2 -4]
             [ 3  0  3 -1]]

    """
    ...

@over
def tile_randi(shape: int32, rng: uint32, min: int32, max: int32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random integers.

    Sample values in the range [min, max).
    """
    ...

@over
def tile_randf(shape: tuple[int, ...], rng: uint32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random floats.

    Args:
        shape: Shape of the output tile
        rng: Random number generator state, typically from :func:`~warp._src.lang.rand_init`
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile of random floats in the range [0, 1) with the specified shape.

    Example:

        .. testcode::

            TILE_M, TILE_N = 2, 2
            M, N = 2, 2
            seed = 42

            @wp.kernel
            def rand_kernel(seed: int, x: wp.array2d(dtype=float)):
                i, j = wp.tid()
                rng = wp.rand_init(seed, i * TILE_M + j)
                t = wp.tile_randf(shape=(TILE_M, TILE_N), rng=rng)
                wp.tile_store(x, t, offset=(i * TILE_M, j * TILE_N))

            x = wp.zeros(shape=(M * TILE_M, N * TILE_N), dtype=float)
            wp.launch_tiled(rand_kernel, dim=[M, N], inputs=[seed, x], block_dim=32)
            print(x.numpy())

        .. testoutput::

            [[0.1859147  0.41986287 0.7774631  0.00414598]
             [0.41634446 0.3073818  0.4827178  0.53220683]
             [0.9400381  0.73490226 0.26666623 0.9250764 ]
             [0.51194566 0.57261354 0.26992965 0.8481429 ]]

    """
    ...

@over
def tile_randf(shape: int32, rng: uint32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random floats."""
    ...

@over
def tile_randf(
    shape: tuple[int, ...], rng: uint32, min: float32, max: float32, storage: str
) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random floats.

    Sample values in the range [min, max).

    Args:
        shape: Shape of the output tile
        rng: Random number generator state, typically from :func:`~warp._src.lang.rand_init`
        min: Minimum value (inclusive) for random floats
        max: Maximum value (exclusive) for random floats
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile of random floats in the range [min, max) with the specified shape.

    Example:

        .. testcode::

            TILE_M, TILE_N = 2, 2
            M, N = 2, 2
            seed = 42

            @wp.kernel
            def rand_range_kernel(seed: int, x: wp.array2d(dtype=float)):
                i, j = wp.tid()
                rng = wp.rand_init(seed, i * TILE_M + j)
                t = wp.tile_randf(shape=(TILE_M, TILE_N), rng=rng, min=-5.0, max=5.0)
                wp.tile_store(x, t, offset=(i * TILE_M, j * TILE_N))

            x = wp.zeros(shape=(M * TILE_M, N * TILE_N), dtype=float)
            wp.launch_tiled(rand_range_kernel, dim=[M, N], inputs=[seed, x], block_dim=32)
            print(x.numpy())

        .. testoutput::

            [[-3.140853   -0.80137134  2.7746308  -4.95854   ]
             [-0.83655536 -1.9261819  -0.17282188  0.32206833]
             [ 4.400381    2.3490226  -2.3333378   4.2507644 ]
             [ 0.11945665  0.7261354  -2.3007035   3.481429  ]]

    """
    ...

@over
def tile_randf(shape: int32, rng: uint32, min: float32, max: float32, storage: str) -> Tile[Any, tuple[int, ...]]:
    """Generate a tile of random floats.

    Sample values in the range [min, max).
    """
    ...

def tile_arange(*args: Scalar, dtype: Scalar, storage: str) -> Tile[Scalar, tuple[int]]:
    """Generate a tile of linearly spaced elements.

    - ``(stop,)``: Generates values from ``0`` to ``stop - 1``
    - ``(start, stop)``: Generates values from ``start`` to ``stop - 1``
    - ``(start, stop, step)``: Generates values from ``start`` to ``stop - 1`` with a step size

    Args:
        args: Variable-length positional arguments, interpreted as:
        dtype: Data type of output tile's elements (optional, default: ``float``)
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.

    Returns:
        A tile with ``shape=(n)`` with linearly spaced elements of specified data type.
    """
    ...

@over
def tile_load(
    a: Array[Any], shape: tuple[int, ...], offset: tuple[int, ...], storage: str, bounds_check: bool
) -> Tile[Any, tuple[int, ...]]:
    """Load a tile from a global memory array.

    This method will cooperatively load a tile from global memory using all threads in the block.

    Args:
        a: The source array in global memory
        shape: Shape of the tile to load, must have the same number of dimensions as ``a``
        offset: Offset in the source array to begin reading from (optional)
        storage: The storage location for the tile: ``"register"`` for registers
            (default) or ``"shared"`` for shared memory.
        bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster load times

    Returns:
        A tile with shape as specified and data type the same as the source array.
    """
    ...

@over
def tile_load(
    a: Array[Any], shape: int32, offset: int32, storage: str, bounds_check: bool
) -> Tile[Any, tuple[int, ...]]:
    """Load a tile from a global memory array."""
    ...

def tile_load_indexed(
    a: Array[Any],
    indices: Tile[int32, tuple[int]],
    shape: tuple[int, ...],
    offset: tuple[int, ...],
    axis: int32,
    storage: str,
) -> Tile[Any, tuple[int, ...]]:
    """Load a tile from a global memory array, with loads along a specified axis mapped according to a 1D tile of indices.

    Args:
        a: The source array in global memory
        indices: A 1D tile of integer indices mapping to elements in ``a``.
        shape: Shape of the tile to load, must have the same number of dimensions as ``a``, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
        offset: Offset in the source array to begin reading from (optional)
        axis: Axis of ``a`` that indices refer to
        storage: The storage location for the tile: ``"register"`` for registers (default) or ``"shared"`` for shared memory.

    Returns:
        A tile with shape as specified and data type the same as the source array.

    Example:

        This example shows how to select and store the even indexed rows from a 2D array.

        .. code-block:: python

            TILE_M = wp.constant(2)
            TILE_N = wp.constant(2)
            HALF_M = wp.constant(TILE_M // 2)
            HALF_N = wp.constant(TILE_N // 2)

            @wp.kernel
            def compute(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
                i, j = wp.tid()

                evens = wp.tile_arange(HALF_M, dtype=int, storage="shared") * 2

                t0 = wp.tile_load_indexed(
                    x,
                    indices=evens,
                    shape=(HALF_M, TILE_N),
                    offset=(i * TILE_M, j * TILE_N),
                    axis=0,
                    storage="register",
                )
                wp.tile_store(y, t0, offset=(i * HALF_M, j * TILE_N))

            M = TILE_M * 2
            N = TILE_N * 2

            arr = np.arange(M * N).reshape(M, N)

            x = wp.array(arr, dtype=float)
            y = wp.zeros((M // 2, N), dtype=float)

            wp.launch_tiled(compute, dim=[2, 2], inputs=[x], outputs=[y], block_dim=32, device=device)

            print(x.numpy())
            print(y.numpy())

        .. code-block:: text

            [[ 0.  1.  2.  3.]
             [ 4.  5.  6.  7.]
             [ 8.  9. 10. 11.]
             12. 13. 14. 15.]]

            [[ 0.  1.  2.  3.]
             [ 8.  9. 10. 11.]]

    """
    ...

@over
def tile_store(a: Array[Any], t: Tile[Any, tuple[int, ...]], offset: tuple[int, ...], bounds_check: bool) -> None:
    """Store a tile to a global memory array.

    This method will cooperatively store a tile to global memory using all threads in the block.

    Args:
        a: The destination array in global memory
        t: The source tile to store data from, must have the same data type and number of dimensions as the destination array
        offset: Offset in the destination array (optional)
        bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster write times.
    """
    ...

@over
def tile_store(a: Array[Any], t: Tile[Any, tuple[int, ...]], offset: int32, bounds_check: bool) -> None:
    """Store a tile to a global memory array."""
    ...

def tile_store_indexed(
    a: Array[Any], indices: Tile[int32, tuple[int]], t: Tile[Any, tuple[int, ...]], offset: tuple[int, ...], axis: int32
) -> None:
    """Store a tile to a global memory array, with storage along a specified axis mapped according to a 1D tile of indices.

    Args:
        a: The destination array in global memory
        indices: A 1D tile of integer indices mapping to elements in ``a``.
        t: The source tile to store data from, must have the same data type and number of dimensions as the destination array, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
        offset: Offset in the destination array (optional)
        axis: Axis of ``a`` that indices refer to.

    Example:

        This example shows how to map tile rows to the even rows of a 2D array.

        .. code-block:: python

            TILE_M = wp.constant(2)
            TILE_N = wp.constant(2)
            TWO_M = wp.constant(TILE_M * 2)
            TWO_N = wp.constant(TILE_N * 2)

            @wp.kernel
            def compute(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
                i, j = wp.tid()

                t = wp.tile_load(x, shape=(TILE_M, TILE_N), offset=(i * TILE_M, j * TILE_N), storage="register")

                evens_M = wp.tile_arange(TILE_M, dtype=int, storage="shared") * 2

                wp.tile_store_indexed(y, indices=evens_M, t=t, offset=(i * TWO_M, j * TILE_N), axis=0)

            M = TILE_M * 2
            N = TILE_N * 2

            arr = np.arange(M * N, dtype=float).reshape(M, N)

            x = wp.array(arr, dtype=float, requires_grad=True, device=device)
            y = wp.zeros((M * 2, N), dtype=float, requires_grad=True, device=device)

            wp.launch_tiled(compute, dim=[2, 2], inputs=[x], outputs=[y], block_dim=32, device=device)

            print(x.numpy())
            print(y.numpy())

        .. code-block:: text

            [[ 0.  1.  2.  3.]
                [ 4.  5.  6.  7.]
                [ 8.  9. 10. 11.]
                [12. 13. 14. 15.]]

            [[ 0.  1.  2.  3.]
                [ 0.  0.  0.  0.]
                [ 4.  5.  6.  7.]
                [ 0.  0.  0.  0.]
                [ 8.  9. 10. 11.]
                [ 0.  0.  0.  0.]
                [12. 13. 14. 15.]
                [ 0.  0.  0.  0.]]

    """
    ...

@over
def tile_atomic_add(
    a: Array[Any], t: Tile[Any, tuple[int, ...]], offset: tuple[int, ...], bounds_check: bool
) -> Tile[Any, tuple[int, ...]]:
    """Atomically add a tile onto the array ``a``.

    Each element is updated atomically.

    Args:
        a: Array in global memory, should have the same ``dtype`` as the input tile
        t: Source tile to add to the destination array
        offset: Offset in the destination array (optional)
        bounds_check: Needed for unaligned tiles, but can disable for memory-aligned tiles for faster write times

    Returns:
        A tile with the same dimensions and data type as the source tile, holding the original value of the destination elements.
    """
    ...

@over
def tile_atomic_add(
    a: Array[Any], t: Tile[Any, tuple[int, ...]], offset: int32, bounds_check: bool
) -> Tile[Any, tuple[int, ...]]:
    """Atomically add a tile onto the array ``a``."""
    ...

def tile_atomic_add_indexed(
    a: Array[Any], indices: Tile[int32, tuple[int]], t: Tile[Any, tuple[int, ...]], offset: tuple[int, ...], axis: int32
) -> Tile[Any, tuple[int, ...]]:
    """Atomically add a tile to a global memory array, with storage along a specified axis mapped according to a 1D tile of indices.

    Args:
        a: The destination array in global memory
        indices: A 1D tile of integer indices mapping to elements in ``a``.
        t: The source tile to extract data from, must have the same data type and number of dimensions as the destination array, and along ``axis``, it must have the same number of elements as the ``indices`` tile.
        offset: Offset in the destination array (optional)
        axis: Axis of ``a`` that indices refer to.

    Example:

        This example shows how to compute a blocked, row-wise reduction.

        .. code-block:: python

            TILE_M = wp.constant(2)
            TILE_N = wp.constant(2)

            @wp.kernel
            def tile_atomic_add_indexed(x: wp.array2d(dtype=float), y: wp.array2d(dtype=float)):
                i, j = wp.tid()

                t = wp.tile_load(x, shape=(TILE_M, TILE_N), offset=(i * TILE_M, j * TILE_N), storage="register")

                zeros = wp.tile_zeros(TILE_M, dtype=int, storage="shared")

                wp.tile_atomic_add_indexed(y, indices=zeros, t=t, offset=(i, j * TILE_N), axis=0)

            M = TILE_M * 2
            N = TILE_N * 2

            arr = np.arange(M * N, dtype=float).reshape(M, N)

            x = wp.array(arr, dtype=float, requires_grad=True, device=device)
            y = wp.zeros((2, N), dtype=float, requires_grad=True, device=device)

            wp.launch_tiled(tile_atomic_add_indexed, dim=[2, 2], inputs=[x], outputs=[y], block_dim=32, device=device)

            print(x.numpy())
            print(y.numpy())

        .. code-block:: text

            [[ 0.  1.  2.  3.]
                [ 4.  5.  6.  7.]
                [ 8.  9. 10. 11.]
                [12. 13. 14. 15.]]

            [[ 4.  6.  8. 10.]
                [20. 22. 24. 26.]]

    """
    ...

def tile_view(
    t: Tile[Any, tuple[int, ...]], offset: tuple[int, ...], shape: tuple[int, ...]
) -> Tile[Any, tuple[int, ...]]:
    """Extract a slice of a given tile [offset, offset+shape], if shape is not specified it will be inferred from the unspecified offset dimensions.

    Args:
        t: Input tile to extract a subrange from
        offset: Offset in the source tile
        shape: Shape of the returned slice

    Returns:
        A tile with dimensions given by the specified shape or the remaining source tile dimensions.
    """
    ...

def tile_squeeze(t: Tile[Any, tuple[int, ...]], axis: tuple[int, ...]) -> Tile[Any, tuple[int, ...]]:
    """Create a squeezed view of a tile with the same data.

    Args:
        t: Input tile to squeeze
        axis: A subset of the entries of length one in the shape (optional)

    Returns:
        The input tile but with all or a subset of the dimensions of length one removed.
    """
    ...

def tile_reshape(t: Tile[Any, tuple[int, ...]], shape: tuple[int, ...]) -> Tile[Any, tuple[int, ...]]:
    """Create a reshaped view of a tile with the same data.

    Args:
        t: Input tile to reshape
        shape: New shape for the tile

    Returns:
        A tile containing the same data as the input tile, but arranged in a new shape.
    """
    ...

def tile_astype(t: Tile[Scalar, tuple[int, ...]], dtype: Scalar) -> Tile[Any, tuple[int, ...]]:
    """Create a new tile with the same data as the input tile, but with a different data type.

    Args:
        t: Input tile
        dtype: New data type for the tile

    Returns:
        A tile with the same data as the input tile, but with a different data type.
    """
    ...

def tile_assign(dst: Tile[Any, tuple[int, ...]], src: Tile[Any, tuple[int, ...]], offset: tuple[int, ...]) -> None:
    """Assign a tile to a subrange of a destination tile.

    Args:
        dst: The destination tile to assign to
        src: The source tile to read values from
        offset: Offset in the destination tile to write to.
    """
    ...

def tile(x: Any, preserve_type: bool) -> Tile[Any, tuple]:
    """Construct a new tile from per-thread kernel values.

    This function converts values computed using scalar kernel code to a tile representation for input into collective operations.

    * If the input value is a scalar, then the resulting tile has ``shape=(block_dim,)``
    * If the input value is a vector, then the resulting tile has ``shape=(length(vector), block_dim)``
    * If the input value is a vector, and ``preserve_type=True``, then the resulting tile has ``dtype=vector`` and ``shape=(block_dim,)``
    * If the input value is a matrix, then the resulting tile has ``shape=(rows, cols, block_dim)``
    * If the input value is a matrix, and ``preserve_type=True``, then the resulting tile has ``dtype=matrix`` and ``shape=(block_dim,)``

    Args:
        x: A per-thread local value, e.g. scalar, vector, or matrix.
        preserve_type: If true, the tile will have the same data type as the input value.

    Returns:
        If ``preserve_type=True``, a tile of type ``x.type`` of length ``block_dim``. Otherwise, an N-dimensional tile such that the first N-1 dimensions match the shape of ``x`` and the final dimension is of size ``block_dim``.

    Example:

        This example shows how to create a linear sequence from thread variables.

        .. code-block:: python

            @wp.kernel
            def compute():
                i = wp.tid()
                t = wp.tile(i * 2)
                print(t)

            wp.launch(compute, dim=16, inputs=[], block_dim=16)

        .. code-block:: text

            [0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30] = tile(shape=(16), storage=register)

    """
    ...

def untile(a: Tile[Any, tuple[int, ...]]) -> Any:
    """Convert a tile back to per-thread values.

    This function converts a block-wide tile back to per-thread values.

    * If the input tile is 1D, then the resulting value will be a per-thread scalar
    * If the input tile is 2D, then the resulting value will be a per-thread vector of length M

    Args:
        a: A tile with dimensions ``shape=(M, block_dim)``

    Returns:
        A single value per-thread with the same data type as the tile.

    Example:

        This example shows how to create a linear sequence from thread variables:

        .. code-block:: python

            @wp.kernel
            def compute():
                i = wp.tid()

                # create block-wide tile
                t = wp.tile(i) * 2

                # convert back to per-thread values
                s = wp.untile(t)

                print(s)

            wp.launch(compute, dim=16, inputs=[], block_dim=16)

        .. code-block:: text

            0
            2
            4
            6
            8
            ...

    """
    ...

@over
def tile_extract(a: Tile[Any, tuple[int]], i: int32) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension

    Returns:
        The value of the element at the specified tile location with the same data type as the input tile.
    """
    ...

@over
def tile_extract(a: Tile[Any, tuple[int, ...]], i: int32, j: int32) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension
        j: Coordinate of element on the second dimension, or vector index

    Returns:
        The value of the element at the specified tile location with the same data type as the input tile.
    """
    ...

@over
def tile_extract(a: Tile[Any, tuple[int, ...]], i: int32, j: int32, k: int32) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension
        j: Coordinate of element on the second dimension, or first matrix index
        k: Coordinate of element on the third dimension, or vector index, or second matrix index

    Returns:
        The value of the element at the specified tile location with the same data type as the input tile.
    """
    ...

@over
def tile_extract(a: Tile[Any, tuple[int, ...]], i: int32, j: int32, k: int32, l: int32) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension
        j: Coordinate of element on the second dimension
        k: Coordinate of element on the third dimension, or first matrix index
        l: Coordinate of element on the fourth dimension, or vector index, or second matrix index

    Returns:
        The value of the element at the specified tile location, with the same data type as the input tile.
    """
    ...

@over
def tile_extract(a: Tile[Any, tuple[int, ...]], i: int32, j: int32, k: int32, l: int32, m: int32) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension
        j: Coordinate of element on the second dimension
        k: Coordinate of element on the third dimension
        l: Coordinate of element on the fourth dimension, or first matrix index
        m: Vector index, or second matrix index

    Returns:
        The value of the element at the specified tile location, with the same data type as the input tile.
    """
    ...

@over
def tile_extract(
    a: Tile[Any, tuple[int, int, int, int]], i: int32, j: int32, k: int32, l: int32, m: int32, n: int32
) -> Any:
    """Extract a single element from the tile.

    This function will extract an element from the tile and broadcast its value to all threads in the block.

    Note that this may incur additional synchronization if the source tile is a register tile.

    Args:
        a: Tile to extract the element from
        i: Coordinate of element on first dimension
        j: Coordinate of element on the second dimension
        k: Coordinate of element on the third dimension
        l: Coordinate of element on the fourth dimension
        m: Vector index, or first matrix index
        n: Second matrix index

    Returns:
        The value of the element at the specified tile location, with the same data type as the input tile.
    """
    ...

def tile_transpose(a: Tile[Any, tuple[int, int]]) -> Tile[Any, tuple[int, int]]:
    """Transpose a tile.

    For shared memory tiles, this operation will alias the input tile.
    Register tiles will first be transferred to shared memory before transposition.

    Args:
        a: Tile to transpose with ``shape=(M,N)``

    Returns:
        Tile with ``shape=(N,M)``.
    """
    ...

def tile_broadcast(a: Tile[Any, tuple[int, ...]], shape: tuple[int, ...]) -> Tile[Any, tuple[int, ...]]:
    """Broadcast a tile.

    Broadcasts the input tile ``a`` to the destination shape.
    Broadcasting follows NumPy broadcast rules.

    Args:
        a: Tile to broadcast
        shape: The shape to broadcast to

    Returns:
        Tile with broadcast shape.
    """
    ...

@over
def tile_sum(a: Tile[Any, tuple[int, ...]], axis: int32) -> Tile[Any, tuple[int, ...]]:
    """Cooperatively compute the sum of the tile elements.

    Reduce across a tile axis using all threads in the block.

    Args:
        a: The input tile. Must reside in shared memory.
        axis: The tile axis to compute the sum across. Must be a compile-time constant.

    Returns:
        A tile with the same shape as the input tile less the axis dimension and the same data type as the input tile.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_ones(dtype=float, shape=(8, 8))
                s = wp.tile_sum(t, axis=0)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [8 8 8 8 8 8 8 8] = tile(shape=(8), storage=register)

    """
    ...

@over
def tile_sum(a: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[Literal[1]]]:
    """Cooperatively compute the sum of the tile elements.

    Reduce across all elements using all threads in the block.

    Args:
        a: The tile to compute the sum of

    Returns:
        A single-element tile holding the sum.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_ones(dtype=float, shape=(16, 16))
                s = wp.tile_sum(t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [256] = tile(shape=(1), storage=register)

    """
    ...

def tile_sort(keys: Tile[Any, tuple[int]], values: Tile[Any, tuple[int]]) -> None:
    """Cooperatively sort the elements of two tiles in ascending order based on the keys, using all threads in the block.

    Args:
        keys: Keys to sort by. Supported key types: :class:`float32`, :class:`int32`, :class:`uint32`, :class:`int64`, :class:`uint64`. Must be in shared memory.
        values: Values to sort along with keys. No type restrictions. Must be in shared memory.

    Returns:
        No return value. Sorts both tiles in-place.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                keys = wp.tile_arange(32, 0, -1, dtype=int, storage="shared")
                values = wp.tile_arange(0, 32, 1, dtype=int, storage="shared")
                wp.tile_sort(keys, values)

                print(keys)
                print(values)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [1, 2, ..., 32] = tile(shape=(32), storage=shared)
            [31, 30, 29, ..., 0] = tile(shape=(32), storage=shared)

    """
    ...

def tile_min(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[Literal[1]]]:
    """Cooperatively compute the minimum of the tile elements using all threads in the block.

    Args:
        a: The tile to compute the minimum of

    Returns:
        A single-element tile holding the minimum value.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_arange(64, 128)
                s = wp.tile_min(t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [64] = tile(shape=(1), storage=register)

    """
    ...

def tile_argmin(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Int, tuple[Literal[1]]]:
    """Cooperatively compute the index of the minimum element in the tile using all threads in the block.

    Args:
        a: The tile to compute the argmin from

    Returns:
        A single-element tile holding the index of the minimum value.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_arange(64, 128)
                s = wp.tile_argmin(t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [0] = tile(shape=(1), storage=register)

    """
    ...

def tile_max(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[Literal[1]]]:
    """Cooperatively compute the maximum of the tile elements using all threads in the block.

    Args:
        a: The tile to compute the maximum from

    Returns:
        A single-element tile holding the maximum value.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_arange(64, 128)
                s = wp.tile_max(t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [127] = tile(shape=(1), storage=register)

    """
    ...

def tile_argmax(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Int, tuple[Literal[1]]]:
    """Cooperatively compute the index of the maximum element in the tile using all threads in the block.

    Args:
        a: The tile to compute the argmax from

    Returns:
        A single-element tile holding the index of the maximum value.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_arange(64, 128)
                s = wp.tile_argmax(t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=64)

        .. code-block:: text

            [63] = tile(shape=(1), storage=register)

    """
    ...

@over
def tile_reduce(op: Callable, a: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[Literal[1]]]:
    """Apply a custom reduction operator across a tile.

    Reduce across all elements using the provided operator.

    Args:
        op: A callable function that accepts two arguments and returns one argument, may be a user function or builtin
        a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type

    Returns:
        A single-element tile with the same data type as the input tile.

    Example:

        .. code-block:: python

            @wp.kernel
            def factorial():
                t = wp.tile_arange(1, 10, dtype=int)
                s = wp.tile_reduce(wp.mul, t)

                print(s)

            wp.launch_tiled(factorial, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [362880] = tile(shape=(1), storage=register)

    """
    ...

@over
def tile_reduce(op: Callable, a: Tile[Scalar, tuple[int, ...]], axis: int32) -> Tile[Scalar, tuple[int, ...]]:
    """Apply a custom reduction operator across a tile.

    Reduce across a tile axis using the provided operator.

    Args:
        op: A callable function that accepts two arguments and returns one argument, may be a user function or builtin
        a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type. Must reside in shared memory.
        axis: The tile axis to perform the reduction across. Must be a compile-time constant.

    Returns:
        A tile with the same shape as the input tile less the axis dimension and the same data type as the input tile.

    Example:

        .. code-block:: python

            TILE_M = wp.constant(4)
            TILE_N = wp.constant(2)

            @wp.kernel
            def compute(x: wp.array2d(dtype=float), y: wp.array(dtype=float)):
                a = wp.tile_load(x, shape=(TILE_M, TILE_N))
                b = wp.tile_reduce(wp.add, a, axis=1)
                wp.tile_store(y, b)

            arr = np.arange(TILE_M * TILE_N).reshape(TILE_M, TILE_N)

            x = wp.array(arr, dtype=float)
            y = wp.zeros(TILE_M, dtype=float)

            wp.launch_tiled(compute, dim=[1], inputs=[x], outputs=[y], block_dim=32)

            print(x.numpy())
            print(y.numpy())

        .. code-block:: text

            [[0. 1.]
             [2. 3.]
             [4. 5.]
             [6. 7.]]
            [ 1.  5.  9. 13.]

    """
    ...

def tile_scan_inclusive(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[int, ...]]:
    """Inclusive scan (prefix sum) across the tile.

    This function cooperatively performs an inclusive scan (cumulative sum) across the tile.

    Args:
        a: The input tile. Must be a tile of type float32, int32, or uint32.

    Returns:
        A new tile containing the inclusive scan result.

    Example:

        .. code-block:: python

            @wp.kernel
            def scan_example():
                t = wp.tile_arange(1, 5, dtype=int)
                s = wp.tile_scan_inclusive(t)
                print(s)

            wp.launch_tiled(scan_example, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [1, 3, 6, 10] = tile(shape=(4), storage=register)

    """
    ...

def tile_scan_exclusive(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[int, ...]]:
    """Exclusive scan (prefix sum) across the tile.

    This function cooperatively performs an exclusive scan (cumulative sum) across the tile.

    Args:
        a: The input tile. Must be a tile of type float32, int32, or uint32.

    Returns:
        A new tile containing the exclusive scan result.

    Example:

        .. code-block:: python

            @wp.kernel
            def scan_example():
                t = wp.tile_arange(1, 5, dtype=int)
                s = wp.tile_scan_exclusive(t)
                print(s)

            wp.launch_tiled(scan_example, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [0, 1, 3, 6] = tile(shape=(4), storage=register)

    """
    ...

def tile_scan_max_inclusive(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[int, ...]]:
    """Inclusive max scan across the tile.

    This function cooperatively performs an inclusive max scan (cumulative maximum) across the tile.

    Args:
        a: The input tile. Must be a tile of type float32, int32, or uint32.

    Returns:
        A new tile containing the inclusive max scan result.

    Example:

        .. code-block:: python

            @wp.kernel
            def scan_example(input: wp.array(dtype=int)):
                t = wp.tile_load(input, shape=(4,))
                s = wp.tile_scan_max_inclusive(t)
                print(s)

            input = wp.array([3, 1, 4, 2], dtype=int)
            wp.launch_tiled(scan_example, dim=[1], inputs=[input], block_dim=16)

        .. code-block:: text

            [3, 3, 4, 4] = tile(shape=(4), storage=register)

    """
    ...

def tile_scan_min_inclusive(a: Tile[Scalar, tuple[int, ...]]) -> Tile[Scalar, tuple[int, ...]]:
    """Inclusive min scan across the tile.

    This function cooperatively performs an inclusive min scan (cumulative minimum) across the tile.

    Args:
        a: The input tile. Must be a tile of type float32, int32, or uint32.

    Returns:
        A new tile containing the inclusive min scan result.

    Example:

        .. code-block:: python

            @wp.kernel
            def scan_example(input: wp.array(dtype=int)):
                t = wp.tile_load(input, shape=(4,))
                s = wp.tile_scan_min_inclusive(t)
                print(s)

            input = wp.array([3, 1, 4, 2], dtype=int)
            wp.launch_tiled(scan_example, dim=[1], inputs=[input], block_dim=16)

        .. code-block:: text

            [3, 1, 1, 1] = tile(shape=(4), storage=register)

    """
    ...

@over
def tile_map(op: Callable, a: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Apply a function to tile elements.

    Apply a unary function to each element using all threads in the block.

    Args:
        op: A callable function that accepts one argument and returns one argument, may be a user function or builtin
        a: The input tile, the operator (or one of its overloads) must be able to accept the tile's data type

    Returns:
        A tile with the same dimensions as the input tile. Its datatype is specified by the return type of ``op``.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                t = wp.tile_arange(0.0, 1.0, 0.1, dtype=float)
                s = wp.tile_map(wp.sin, t)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [0 0.0998334 0.198669 0.29552 0.389418 0.479426 0.564642 0.644218 0.717356 0.783327] = tile(shape=(10), storage=register)

    """
    ...

@over
def tile_map(op: Callable, a: Tile[Any, tuple[int, ...]], b: Any) -> Tile[Any, tuple[int, ...]]:
    """Apply a function to tile elements.

    This function cooperatively applies a binary function to each element of the tile using all threads in the block.
    The second argument can be a tile (must have same dimensions as ``a``), or a non-tile constant (scalar, vector, or matrix)
    which will be broadcast across all elements.

    Args:
        op: A callable function that accepts two arguments and returns one argument, all of the same type, may be a user function or builtin.
        a: The first input tile, the operator (or one of its overloads) must be able to accept the tile's dtype.
        b: Either a tile with matching dimensions, or a scalar/vector/matrix constant.

    Returns:
        A tile with the same dimensions as tile ``a``. Its datatype is specified by the return type of ``op``.

    Example:

        .. code-block:: python

            @wp.kernel
            def compute():
                a = wp.tile_arange(0.0, 1.0, 0.1, dtype=float)
                b = wp.tile_ones(shape=10, dtype=float)

                s = wp.tile_map(wp.add, a, b)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9] = tile(shape=(10), storage=register)

    """
    ...

@over
def tile_map(op: Callable, a: Tile[Any, tuple[int, ...]], *args: Any) -> Tile[Scalar, tuple[int, ...]]:
    """Apply a function to tile elements.

    This function cooperatively applies a user-defined function to corresponding elements using all threads in the block.
    The first argument 'a' must be a tile (determines output shape). Additional arguments can be tiles (must have same dimensions)
    or non-tile constants (scalar, vector, or matrix) which will be broadcast across all elements.

    Args:
        op: A callable function that accepts N arguments and returns one value, must be a user function.
        a: The first input tile, determines the output shape.
        args: Additional arguments: tiles with matching dimensions, or scalar/vector/matrix constants.

    Returns:
        A tile with the same dimensions as tile ``a``. Its datatype is specified by the return type of ``op``.

    Example:

        .. code-block:: python

            @wp.func
            def weighted_sum(a: float, b: float, c: float):
                return 0.5 * a + 0.3 * b + 0.2 * c

            @wp.kernel
            def compute():
                a = wp.tile_arange(0.0, 1.0, 0.1, dtype=float)
                b = wp.tile_ones(shape=10, dtype=float)
                c = wp.tile_arange(1.0, 2.0, 0.1, dtype=float)

                s = wp.tile_map(weighted_sum, a, b, c)

                print(s)

            wp.launch_tiled(compute, dim=[1], inputs=[], block_dim=16)

        .. code-block:: text

            [0.5 0.57 0.64 0.71 0.78 0.85 0.92 0.99 1.06 1.13] = tile(shape=(10), storage=register)

    """
    ...

def bvh_query_aabb(id: uint64, low: vec3f, high: vec3f, root: int32) -> BvhQuery:
    """Construct an axis-aligned bounding box query against a BVH object.

    This query can be used to iterate over all bounds inside a BVH.
    To start a query from a specific node, set ``root`` to the index of the node. The root
    can be obtained using the :func:`bvh_get_group_root` function when creating a grouped BVH.
    When ``root`` is a valid (>=0) value, the traversal will be confined to the subtree starting from the root.
    If ``root`` is -1 (default), traversal starts at the BVH's global root.
    The query will only traverse down from that node, limiting traversal to that subtree.

    Args:
        id: The BVH identifier
        low: The lower bound of the bounding box in BVH space
        high: The upper bound of the bounding box in BVH space
        root: The root to begin the query from (optional, default: -1)
    """
    ...

def bvh_query_ray(id: uint64, start: vec3f, dir: vec3f, root: int32) -> BvhQuery:
    """Construct a ray query against a BVH object.

    This query can be used to iterate over all bounds that intersect the ray.
    To start a query from a specific node, set ``root`` to the index of the node. The root
    can be obtained using the :func:`bvh_get_group_root` function when creating a grouped BVH.
    When ``root`` is a valid (>=0) value, the traversal will be confined to the subtree starting from the root.
    If ``root`` is -1 (default), traversal starts at the BVH's global root.
    The query will only traverse down from that node, limiting traversal to that subtree.

    Args:
        id: The BVH identifier
        start: The start of the ray in BVH space
        dir: The direction of the ray in BVH space (should be normalized)
        root: The root to begin the query from (optional, default: -1)
    """
    ...

def bvh_query_next(query: BvhQuery, index: int32, max_dist: float32) -> bool:
    """Move to the next bound returned by the query.

    The index of the current bound is stored in ``index``, returns ``False`` if there are no more overlapping bounds.
    The maximum distance along a ray query to check for intersections can be set using ``max_dist``. It is not effective
    for aabb query.

    Note that increasing ``max_dist`` may result in missing intersections. Since previously rejected subtrees will never be
    revisited even if it intersects with the new, longer ray. In other words, it's only safe to monotonically
    reduce ``max_dist`` during a query.

    Args:
        query: The query to move to the next bound
        index: The index of the current bound
        max_dist: The maximum distance along the ray to check for intersections for ray queries. Not effective for aabb query.
    """
    ...

def bvh_query_aabb_tiled(id: uint64, low: vec3f, high: vec3f) -> BvhQueryTiled:
    """Construct an axis-aligned bounding box query against a BVH object for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a BVH across a thread block.

    Args:
        id: The BVH identifier
        low: The lower bound of the bounding box in BVH space (must be the same for all threads in the block)
        high: The upper bound of the bounding box in BVH space (must be the same for all threads in the block)
    """
    ...

def bvh_query_ray_tiled(id: uint64, start: vec3f, dir: vec3f) -> BvhQueryTiled:
    """Construct a ray query against a BVH object for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a BVH across a thread block.

    Args:
        id: The BVH identifier
        start: The ray origin (must be the same for all threads in the block)
        dir: The ray direction (must be the same for all threads in the block)
    """
    ...

def bvh_query_next_tiled(query: BvhQueryTiled) -> Tile[int32, tuple[int]]:
    """Move to the next bound in a thread-block parallel BVH query and return results as a tile.

    Each thread in the block receives one result index in the returned tile, or -1 if no result for that thread.
    The function returns a register tile of shape ``(block_dim,)`` containing the result indices.

    To check if any results were found, check if any element in the tile is >= 0.

    Args:
        query: The thread-block BVH query object

    Returns:
        A register tile of shape ``(block_dim,)`` with dtype int, where each element contains
            the result index for that thread (-1 if no result)
    """
    ...

def tile_bvh_query_aabb(id: uint64, low: vec3f, high: vec3f) -> BvhQueryTiled:
    """Construct an axis-aligned bounding box query against a BVH object for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a BVH across a thread block.

    .. note:: This is an alias for :func:`bvh_query_aabb_tiled`.

    Args:
        id: The BVH identifier
        low: The lower bound of the bounding box in BVH space (must be the same for all threads in the block)
        high: The upper bound of the bounding box in BVH space (must be the same for all threads in the block)
    """
    ...

def tile_bvh_query_ray(id: uint64, start: vec3f, dir: vec3f) -> BvhQueryTiled:
    """Construct a ray query against a BVH object for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a BVH across a thread block.

    .. note:: This is an alias for :func:`bvh_query_ray_tiled`.

    Args:
        id: The BVH identifier
        start: The ray origin (must be the same for all threads in the block)
        dir: The ray direction (must be the same for all threads in the block)
    """
    ...

def tile_bvh_query_next(query: BvhQueryTiled) -> Tile[int32, tuple[int]]:
    """Move to the next bound in a thread-block parallel BVH query and return results as a tile.

    Each thread in the block receives one result index in the returned tile, or -1 if no result for that thread.
    The function returns a register tile of shape ``(block_dim,)`` containing the result indices.

    To check if any results were found, check if any element in the tile is >= 0.

    .. note:: This is an alias for :func:`bvh_query_next_tiled`.

    Args:
        query: The thread-block BVH query object

    Returns:
        A register tile of shape ``(block_dim,)`` with dtype int, where each element contains
            the result index for that thread (-1 if no result)
    """
    ...

def bvh_get_group_root(id: uint64, group: int32) -> int:
    """Get the root of a group in a BVH.

    Args:
        id: The BVH identifier
        group: The group identifier

    Returns:
        The root node index for the specified group. If the group does not exist, returns ``-1``
            (sentinel for the BVH global root). Pass ``-1`` to BVH queries to traverse from the global root.
    """
    ...

def mesh_get_group_root(id: uint64, group: int32) -> int:
    """Get the root of a group in a :class:`warp.Mesh`.

    Args:
        id: The mesh identifier
        group: The group identifier

    Returns:
        The root node index for the specified group. If the group does not exist, returns ``-1``
            (sentinel for the mesh's global root). Pass ``-1`` to mesh queries to traverse from the global root.
    """
    ...

def mesh_query_point(id: uint64, point: vec3f, max_dist: float32) -> MeshQueryPoint:
    """Compute the closest point on the :class:`warp.Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance using additional ray-casts to determine if the point is inside or outside.
    This method is relatively robust, but does increase computational cost.
    See below for additional sign determination methods.

    Args:
        id: The mesh identifier
        point: The point in space to query
        max_dist: Mesh faces above this distance will not be considered by the query.
    """
    ...

def mesh_query_point_sign_parity(
    id: uint64, point: vec3f, max_dist: float32, n_sample: int32, perturbation_scale: float32
) -> MeshQueryPoint:
    """Compute the closest point on the :class:`warp.Mesh` with identifier ``id`` to the given ``point`` in space.

    The method will cast multiple rays starting from the query point by applying
    small random perturbations to a base direction (1, 1, 1). Each perturbation is
    sampled independently for the x, y, and z dimensions from a uniform distribution
    in the range [-perturbation_scale, perturbation_scale), and added to the base
    direction to produce a slightly altered ray direction. This randomization helps
    avoid degeneracies such as rays intersecting exactly on triangle edges,
    vertices, or becoming parallel to mesh features.

    For each perturbed ray, the method counts how many mesh faces it intersects and
    uses the parity (odd/even) of this count to determine whether the ray exits the
    mesh (odd -> inside, even -> outside). A majority vote over all sampled rays is
    used to classify the point.

    Args:
        id: The mesh identifier
        point: The point in space to query
        max_dist: Mesh faces above this distance will not be considered by the query
        n_sample: Number of rays to cast (default: 1). Use a higher value if the sign is inaccurate.
        perturbation_scale: Scale of the perturbation.

    """
    ...

def mesh_query_point_no_sign(id: uint64, point: vec3f, max_dist: float32) -> MeshQueryPoint:
    """Compute the closest point on the :class:`warp.Mesh` with identifier ``id`` to the given ``point`` in space.

    This method does not compute the sign of the point (inside/outside) which makes it faster than other point query methods.

    Args:
        id: The mesh identifier
        point: The point in space to query
        max_dist: Mesh faces above this distance will not be considered by the query.
    """
    ...

def mesh_query_furthest_point_no_sign(id: uint64, point: vec3f, min_dist: float32) -> MeshQueryPoint:
    """Compute the furthest point on the :class:`warp.Mesh` with identifier ``id`` to the given point in space.

    This method does not compute the sign of the point (inside/outside).

    Args:
        id: The mesh identifier
        point: The point in space to query
        min_dist: Mesh faces below this distance will not be considered by the query.
    """
    ...

def mesh_query_point_sign_normal(id: uint64, point: vec3f, max_dist: float32, epsilon: float32) -> MeshQueryPoint:
    """Compute the closest point on the :class:`warp.Mesh` with identifier ``id`` to the given ``point`` in space.

    Identifies the sign of the distance (inside/outside) using the angle-weighted pseudo normal.
    This approach to sign determination is robust for well conditioned meshes that are watertight and non-self intersecting.
    It is also comparatively fast to compute.

    Args:
        id: The mesh identifier
        point: The point in space to query
        max_dist: Mesh faces above this distance will not be considered by the query
        epsilon: Epsilon treating distance values as equal, when locating the minimum distance vertex/face/edge, as a
            fraction of the average edge length, also for treating closest point as being on edge/vertex default 1e-3.
    """
    ...

def mesh_query_point_sign_winding_number(
    id: uint64, point: vec3f, max_dist: float32, accuracy: float32, threshold: float32
) -> MeshQueryPoint:
    """Compute the closest point on the :class:`warp.Mesh` with identifier ``id`` to the given point in space.

    Identifies the sign using the winding number of the mesh relative to the query point. This method of sign determination is robust for poorly conditioned meshes
    and provides a smooth approximation to sign even when the mesh is not watertight. This method is the most robust and accurate of the sign determination meshes
    but also the most expensive.

    .. note:: The :class:`warp.Mesh` object must be constructed with ``support_winding_number=True`` for this method to return correct results.

    Args:
        id: The mesh identifier
        point: The point in space to query
        max_dist: Mesh faces above this distance will not be considered by the query
        accuracy: Accuracy for computing the winding number with fast winding number method utilizing second-order dipole approximation, default 2.0
        threshold: The threshold of the winding number to be considered inside, default 0.5.
    """
    ...

def mesh_query_ray(id: uint64, start: vec3f, dir: vec3f, max_t: float32, root: int32) -> MeshQueryRay:
    """Compute the closest ray hit on the :class:`warp.Mesh` with identifier ``id``.

    The ``root`` parameter can be obtained using the :func:`mesh_get_group_root` function when creating a grouped mesh.
    When ``root`` is a valid (>=0) value, the traversal will be confined to the subtree starting from the root.
    If ``root`` is -1 (default), traversal starts at the mesh's global root.

    Args:
        id: The mesh identifier
        start: The start point of the ray
        dir: The ray direction (should be normalized)
        max_t: The maximum distance along the ray to check for intersections
        root: The root node index for grouped BVH queries, or -1 for global root (optional, default: -1)
    """
    ...

def mesh_query_ray_anyhit(id: uint64, start: vec3f, dir: vec3f, max_t: float32, root: int32) -> bool:
    """Check for any ray hit on the :class:`warp.Mesh` with identifier ``id``.

    The ``root`` parameter can be obtained using the :func:`mesh_get_group_root` function when creating a grouped mesh.
    When ``root`` is a valid (>=0) value, the traversal will be confined to the subtree starting from the root.
    If ``root`` is -1 (default), traversal starts at the mesh's global root.

    Args:
        id: The mesh identifier
        start: The start point of the ray
        dir: The ray direction (should be normalized)
        max_t: The maximum distance along the ray to check for intersections
        root: The root node index for grouped BVH queries, or -1 for global root (optional, default: -1)
    """
    ...

def mesh_query_ray_count_intersections(id: uint64, start: vec3f, dir: vec3f, root: int32) -> int:
    """Count the number of intersections between a ray and a :class:`warp.Mesh`.

    This function casts a ray through the mesh and counts all triangle intersections with ``t >= 0``.
    Unlike :func:`mesh_query_ray`, this function does not stop at the first hit and continues
    traversing to count all intersections along the entire ray.

    This function can be used to determine whether the ray origin lies inside a watertight, intersection-free mesh.
    An odd number of intersections indicates the origin is inside the mesh, while an even number indicates it is outside.

    The ``root`` parameter can be obtained using the :func:`mesh_get_group_root` function when creating a grouped mesh.
    When ``root`` is a valid (>=0) value, the traversal will be confined to the subtree starting from the root.
    If ``root`` is -1 (default), traversal starts at the mesh's global root.

    Args:
        id: The mesh identifier
        start: The start point of the ray
        dir: The ray direction (should be normalized)
        root: The root node index for grouped BVH queries, or -1 for global root (optional, default: -1)

    Returns:
        The number of intersections (with ``t >= 0``) between the ray and the mesh.
    """
    ...

def mesh_query_aabb(id: uint64, low: vec3f, high: vec3f) -> MeshQueryAABB:
    """Construct an axis-aligned bounding box query against a :class:`warp.Mesh`.

    This query can be used to iterate over all bounding boxes of the triangles inside a volume.

    Args:
        id: The mesh identifier
        low: The lower bound of the bounding box in mesh space
        high: The upper bound of the bounding box in mesh space.
    """
    ...

def mesh_query_aabb_next(query: MeshQueryAABB, index: int32) -> bool:
    """Move to the next triangle whose bounding box overlaps the query bounding box.

    The index of the current face is stored in ``index``, returns ``False`` if there are no more overlapping triangles.
    """
    ...

def mesh_query_aabb_tiled(id: uint64, low: vec3f, high: vec3f) -> MeshQueryAABBTiled:
    """Construct an axis-aligned bounding box query against a :class:`warp.Mesh` for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a mesh's BVH across a thread block.

    Args:
        id: The mesh identifier
        low: The lower bound of the bounding box in mesh space (must be the same for all threads in the block)
        high: The upper bound of the bounding box in mesh space (must be the same for all threads in the block)
    """
    ...

def mesh_query_aabb_next_tiled(query: MeshQueryAABBTiled) -> Tile[int32, tuple[int]]:
    """Move to the next triangle in a thread-block parallel mesh AABB query and return results as a tile.

    Each thread in the block receives one result index in the returned tile, or -1 if no result for that thread.
    The function returns a register tile of shape ``(block_dim,)`` containing the result indices.

    To check if any results were found, check if any element in the tile is >= 0.

    Args:
        query: The thread-block mesh query object

    Returns:
        A register tile of shape ``(block_dim,)`` with dtype int, where each element contains
            the result index for that thread (-1 if no result)
    """
    ...

def tile_mesh_query_aabb(id: uint64, low: vec3f, high: vec3f) -> MeshQueryAABBTiled:
    """Construct an axis-aligned bounding box query against a :class:`warp.Mesh` for thread-block parallel traversal.

    This query can be used in tiled kernels to cooperatively traverse a mesh's BVH across a thread block.


    .. note:: This is an alias for :func:`mesh_query_aabb_tiled`.

    Args:
        id: The mesh identifier
        low: The lower bound of the bounding box in mesh space (must be the same for all threads in the block)
        high: The upper bound of the bounding box in mesh space (must be the same for all threads in the block)
    """
    ...

def tile_mesh_query_aabb_next(query: MeshQueryAABBTiled) -> Tile[int32, tuple[int]]:
    """Move to the next triangle in a thread-block parallel mesh AABB query and return results as a tile.

    Each thread in the block receives one result index in the returned tile, or -1 if no result for that thread.
    The function returns a register tile of shape ``(block_dim,)`` containing the result indices.

    To check if any results were found, check if any element in the tile is >= 0.


    .. note:: This is an alias for :func:`mesh_query_aabb_next_tiled`.

    Args:
        query: The thread-block mesh query object

    Returns:
        A register tile of shape ``(block_dim,)`` with dtype int, where each element contains
            the result index for that thread (-1 if no result)
    """
    ...

def mesh_eval_position(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f:
    """Evaluate the position on the :class:`warp.Mesh` given a face index and barycentric coordinates."""
    ...

def mesh_eval_velocity(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec3f:
    """Evaluate the velocity on the :class:`warp.Mesh` given a face index and barycentric coordinates."""
    ...

def hash_grid_query(id: uint64, point: vec3f, max_dist: float32) -> HashGridQuery:
    """Construct a point query against a :class:`warp.HashGrid`.

    This query can be used to iterate over all neighboring point within a fixed radius from the query point.
    """
    ...

def hash_grid_query_next(query: HashGridQuery, index: int32) -> bool:
    """Move to the next point in the hash grid query.

    The index of the current neighbor is stored in ``index``, returns ``False`` if there are no more neighbors.
    """
    ...

def hash_grid_point_id(id: uint64, index: int32) -> int:
    """Query the index of a point in the :class:`warp.HashGrid`.

    This can be used to reorder threads such that grid traversal occurs in a spatially coherent order.

    Returns:
        -1 if the :class:`warp.HashGrid` has not been reserved.
    """
    ...

@over
def intersect_tri_tri(v0: vec3f, v1: vec3f, v2: vec3f, u0: vec3f, u1: vec3f, u2: vec3f) -> int:
    """Test for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Mller's method.

    This function works with single precision, may return incorrect results in some case.

    Returns:
        > 0 if triangles intersect.
    """
    ...

@over
def intersect_tri_tri(v0: vec3d, v1: vec3d, v2: vec3d, u0: vec3d, u1: vec3d, u2: vec3d) -> int:
    """Test for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Mller's method.

    This function works with double precision, results are more accurate than the single precision version.

    Returns:
        > 0 if triangles intersect.
    """
    ...

def mesh_get(id: uint64) -> Mesh:
    """Retrieve the mesh given its index."""
    ...

def mesh_eval_face_normal(id: uint64, face: int32) -> vec3f:
    """Evaluate the face normal the mesh given a face index."""
    ...

def mesh_get_point(id: uint64, index: int32) -> vec3f:
    """Query the point of the mesh given an index."""
    ...

def mesh_get_velocity(id: uint64, index: int32) -> vec3f:
    """Query the velocity of the mesh given an index."""
    ...

def mesh_get_index(id: uint64, index: int32) -> int:
    """Query the point-index of the mesh given a face-vertex index."""
    ...

def closest_point_edge_edge(p1: vec3f, q1: vec3f, p2: vec3f, q2: vec3f, epsilon: float32) -> vec3f:
    """Find the closest points between two edges.

    Args:
        p1: First point of first edge
        q1: Second point of first edge
        p2: First point of second edge
        q2: Second point of second edge
        epsilon: Zero tolerance for determining if points in an edge are degenerate.
        out: vec3 output containing (s,t,d), where ``s`` in [0,1] is the barycentric weight for the first edge, ``t`` is the barycentric weight for the second edge, and ``d`` is the distance between the two edges at these two closest points.

    Returns:
        Barycentric weights to the points on each edge, as well as the closest distance between the edges.
    """
    ...

def volume_sample(id: uint64, uvw: vec3f, sampling_mode: int32, dtype: Any) -> Any:
    """Sample the volume of type ``dtype`` given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    """
    ...

def volume_sample_grad(id: uint64, uvw: vec3f, sampling_mode: int32, grad: Any, dtype: Any) -> Any:
    """Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    """
    ...

def volume_lookup(id: uint64, i: int32, j: int32, k: int32, dtype: Any) -> Any:
    """Query the value of voxel with coordinates ``i``, ``j``, ``k`` for a volume of type ``dtype``.

    If the voxel at this index does not exist, this function returns the background value.
    """
    ...

def volume_store(id: uint64, i: int32, j: int32, k: int32, value: Any) -> None:
    """Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``."""
    ...

def volume_sample_f(id: uint64, uvw: vec3f, sampling_mode: int32) -> float:
    """Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    """
    ...

def volume_sample_grad_f(id: uint64, uvw: vec3f, sampling_mode: int32, grad: vec3f) -> float:
    """Sample the volume and its gradient given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    """
    ...

def volume_lookup_f(id: uint64, i: int32, j: int32, k: int32) -> float:
    """Query the value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.
    """
    ...

def volume_store_f(id: uint64, i: int32, j: int32, k: int32, value: float32) -> None:
    """Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``."""
    ...

def volume_sample_v(id: uint64, uvw: vec3f, sampling_mode: int32) -> vec3f:
    """Sample the vector volume given by ``id`` at the volume local-space point ``uvw``.

    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    """
    ...

def volume_lookup_v(id: uint64, i: int32, j: int32, k: int32) -> vec3f:
    """Query the vector value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.
    """
    ...

def volume_store_v(id: uint64, i: int32, j: int32, k: int32, value: vec3f) -> None:
    """Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``."""
    ...

def volume_sample_i(id: uint64, uvw: vec3f) -> int:
    """Sample the :class:`int32` volume given by ``id`` at the volume local-space point ``uvw``."""
    ...

def volume_lookup_i(id: uint64, i: int32, j: int32, k: int32) -> int:
    """Query the :class:`int32` value of voxel with coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns the background value.
    """
    ...

def volume_store_i(id: uint64, i: int32, j: int32, k: int32, value: int32) -> None:
    """Store ``value`` at the voxel with coordinates ``i``, ``j``, ``k``."""
    ...

def volume_sample_index(id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any) -> Any:
    """Sample the volume given by ``id`` at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and ``background`` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.

    """
    ...

def volume_sample_grad_index(
    id: uint64, uvw: vec3f, sampling_mode: int32, voxel_data: Array[Any], background: Any, grad: Any
) -> Any:
    """Sample the volume given by ``id`` and its gradient at the volume local-space point ``uvw``.

    Values for allocated voxels are read from the ``voxel_data`` array, and ``background`` is used as the value of non-existing voxels.
    Interpolation should be :attr:`warp.Volume.CLOSEST` or :attr:`warp.Volume.LINEAR`.
    This function is available for both index grids and classical volumes.

    """
    ...

def volume_lookup_index(id: uint64, i: int32, j: int32, k: int32) -> int32:
    """Query the index associated with the voxel at coordinates ``i``, ``j``, ``k``.

    If the voxel at this index does not exist, this function returns -1.
    This function is available for both index grids and classical volumes.

    """
    ...

def volume_index_to_world(id: uint64, uvw: vec3f) -> vec3f:
    """Transform a point ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation."""
    ...

def volume_world_to_index(id: uint64, xyz: vec3f) -> vec3f:
    """Transform a point ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation."""
    ...

def volume_index_to_world_dir(id: uint64, uvw: vec3f) -> vec3f:
    """Transform a direction ``uvw`` defined in volume index space to world space given the volume's intrinsic affine transformation."""
    ...

def volume_world_to_index_dir(id: uint64, xyz: vec3f) -> vec3f:
    """Transform a direction ``xyz`` defined in volume world space to the volume's index space given the volume's intrinsic affine transformation."""
    ...

@over
def texture_sample(tex: Texture2D, uv: vec2f, dtype: Any) -> Any:
    """Sample the 2D texture at the given UV coordinates.

    :param tex: The 2D texture to sample.
    :param uv: UV coordinates as a vec2f. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, width] x [0, height] if ``normalized_coords=False``.
    :param dtype: The return type (float, vec2f, or vec4f).
    :returns: The sampled value of the specified dtype.

    Filtering mode is :attr:`warp.TextureFilterMode.CLOSEST` or :attr:`warp.TextureFilterMode.LINEAR`.
    """
    ...

@over
def texture_sample(tex: Texture2D, u: float32, v: float32, dtype: Any) -> Any:
    """Sample the 2D texture at the given UV coordinates.

    :param tex: The 2D texture to sample.
    :param u: U coordinate. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, width] if ``normalized_coords=False``.
    :param v: V coordinate. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, height] if ``normalized_coords=False``.
    :param dtype: The return type (float, vec2f, or vec4f).
    :returns: The sampled value of the specified dtype.

    Filtering mode is :attr:`warp.TextureFilterMode.CLOSEST` or :attr:`warp.TextureFilterMode.LINEAR`.
    """
    ...

@over
def texture_sample(tex: Texture3D, uvw: vec3f, dtype: Any) -> Any:
    """Sample the 3D texture at the given UVW coordinates.

    :param tex: The 3D texture to sample.
    :param uvw: UVW coordinates as a vec3f. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, width] x [0, height] x [0, depth] if ``normalized_coords=False``.
    :param dtype: The return type (float, vec2f, or vec4f).
    :returns: The sampled value of the specified dtype.

    Filtering mode is :attr:`warp.TextureFilterMode.CLOSEST` or :attr:`warp.TextureFilterMode.LINEAR`.
    """
    ...

@over
def texture_sample(tex: Texture3D, u: float32, v: float32, w: float32, dtype: Any) -> Any:
    """Sample the 3D texture at the given UVW coordinates.

    :param tex: The 3D texture to sample.
    :param u: U coordinate. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, width] if ``normalized_coords=False``.
    :param v: V coordinate. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, height] if ``normalized_coords=False``.
    :param w: W coordinate. Range is [0, 1] if the texture was created with
        ``normalized_coords=True`` (default), or [0, depth] if ``normalized_coords=False``.
    :param dtype: The return type (float, vec2f, or vec4f).
    :returns: The sampled value of the specified dtype.

    Filtering mode is :attr:`warp.TextureFilterMode.CLOSEST` or :attr:`warp.TextureFilterMode.LINEAR`.
    """
    ...

@over
def rand_init(seed: int32) -> uint32:
    """Initialize a random number generator.

    Initialize from a user-defined seed.

    Returns:
        A 32-bit integer representing the RNG state.
    """
    ...

@over
def rand_init(seed: int32, offset: int32) -> uint32:
    """Initialize a random number generator.

    Initialize from a user-defined seed and an offset.

    This alternative constructor can be useful in parallel programs, where a kernel as a whole should share a seed,
    but each thread should generate uncorrelated values. In this case usage should be ``r = rand_init(seed, tid)``.
    """
    ...

@over
def randi(state: uint32) -> int:
    """Generate a random integer.

    Sample in the range [-2^31, 2^31).
    """
    ...

@over
def randi(state: uint32, low: int32, high: int32) -> int:
    """Generate a random integer.

    Sample in the range [low, high).
    """
    ...

@over
def randu(state: uint32) -> uint32:
    """Generate a random unsigned integer.

    Sample in the range [0, 2^32).
    """
    ...

@over
def randu(state: uint32, low: uint32, high: uint32) -> uint32:
    """Generate a random unsigned integer.

    Sample in the range [low, high).
    """
    ...

@over
def randf(state: uint32) -> float:
    """Generate a random float.

    Sample in the range [0.0, 1.0).
    """
    ...

@over
def randf(state: uint32, low: float32, high: float32) -> float:
    """Generate a random float.

    Sample in the range [low, high).
    """
    ...

def randn(state: uint32) -> float:
    """Sample a normal (Gaussian) distribution of mean 0 and variance 1."""
    ...

def sample_cdf(state: uint32, cdf: Array[float32]) -> int:
    """Inverse-transform sample a cumulative distribution function."""
    ...

def sample_triangle(state: uint32) -> vec2f:
    """Uniformly sample a triangle.

    Returns:
        Sample barycentric coordinates.
    """
    ...

def sample_unit_ring(state: uint32) -> vec2f:
    """Uniformly sample a ring in the xy plane."""
    ...

def sample_unit_disk(state: uint32) -> vec2f:
    """Uniformly sample a disk in the xy plane."""
    ...

def sample_unit_sphere_surface(state: uint32) -> vec3f:
    """Uniformly sample a unit sphere surface."""
    ...

def sample_unit_sphere(state: uint32) -> vec3f:
    """Uniformly sample a unit sphere."""
    ...

def sample_unit_hemisphere_surface(state: uint32) -> vec3f:
    """Uniformly sample a unit hemisphere surface."""
    ...

def sample_unit_hemisphere(state: uint32) -> vec3f:
    """Uniformly sample a unit hemisphere."""
    ...

def sample_unit_square(state: uint32) -> vec2f:
    """Uniformly sample a unit square."""
    ...

def sample_unit_cube(state: uint32) -> vec3f:
    """Uniformly sample a unit cube."""
    ...

def poisson(state: uint32, lam: float32) -> uint32:
    """Generate a random sample from a Poisson distribution.

    Args:
        state: RNG state
        lam: The expected value of the distribution.
    """
    ...

@over
def noise(state: uint32, x: float32) -> float:
    """Non-periodic Perlin-style noise.

    Sample 1D noise.
    """
    ...

@over
def noise(state: uint32, xy: vec2f) -> float:
    """Non-periodic Perlin-style noise.

    Sample 2D noise.
    """
    ...

@over
def noise(state: uint32, xyz: vec3f) -> float:
    """Non-periodic Perlin-style noise.

    Sample 3D noise.
    """
    ...

@over
def noise(state: uint32, xyzt: vec4f) -> float:
    """Non-periodic Perlin-style noise.

    Sample 4D noise.
    """
    ...

@over
def pnoise(state: uint32, x: float32, px: int32) -> float:
    """Periodic Perlin-style noise.

    Sample 1D noise.
    """
    ...

@over
def pnoise(state: uint32, xy: vec2f, px: int32, py: int32) -> float:
    """Periodic Perlin-style noise.

    Sample 2D noise.
    """
    ...

@over
def pnoise(state: uint32, xyz: vec3f, px: int32, py: int32, pz: int32) -> float:
    """Periodic Perlin-style noise.

    Sample 3D noise.
    """
    ...

@over
def pnoise(state: uint32, xyzt: vec4f, px: int32, py: int32, pz: int32, pt: int32) -> float:
    """Periodic Perlin-style noise.

    Sample 4D noise.
    """
    ...

@over
def curlnoise(state: uint32, xy: vec2f, octaves: uint32, lacunarity: float32, gain: float32) -> vec2f:
    """Divergence-free vector field based on Perlin noise.

    Use the gradient of a Perlin noise function.
    """
    ...

@over
def curlnoise(state: uint32, xyz: vec3f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f:
    """Divergence-free vector field based on Perlin noise.

    Use the curl of three Perlin noise functions.
    """
    ...

@over
def curlnoise(state: uint32, xyzt: vec4f, octaves: uint32, lacunarity: float32, gain: float32) -> vec3f:
    """Divergence-free vector field based on Perlin noise.

    Use the curl of three Perlin noise functions.
    """
    ...

def printf(fmt: str, *args: Any) -> None:
    """Allows printing formatted strings using C-style format specifiers."""
    ...

def print(value: Any) -> None:
    """Print a variable to stdout."""
    ...

def breakpoint() -> None:
    """Trigger a debugger breakpoint."""
    ...

def tid() -> int | tuple[int, int] | tuple[int, int, int] | tuple[int, int, int, int]:
    """Query the current thread index or indices.

    The return type is determined by the unpacking syntax used:

    - ``i = wp.tid()`` - Returns the first thread index as ``int``
    - ``i, j = wp.tid()`` - Returns the first two indices as ``tuple[int, int]``
    - ``i, j, k = wp.tid()`` - Returns the first three indices as ``tuple[int, int, int]``
    - ``i, j, k, l = wp.tid()`` - Returns all four indices as ``tuple[int, int, int, int]``

    The indices correspond to the thread's position in the kernel launch grid.
    If fewer indices are requested than the launch dimensionality, only the
    leading indices are returned.

    This function may not be called from user-defined Warp functions.
    """
    ...

def block_dim() -> int:
    """Query the number of threads in the current block."""
    ...

@over
def select(cond: bool, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: int8, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: uint8, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: int16, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: uint16, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: int32, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: uint32, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: int64, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(cond: uint64, value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``False`` then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(cond, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def select(arr: Array[Any], value_if_false: Any, value_if_true: Any) -> Any:
    """Select between two arguments, if ``arr`` is null then return ``value_if_false``, otherwise return ``value_if_true``.

    .. versionremoved:: 1.10
            Use :func:`where` instead, which has the more intuitive argument order:
            ``where(arr, value_if_true, value_if_false)``.

    .. deprecated:: 1.7
    """
    ...

@over
def where(cond: bool, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: int8, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: uint8, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: int16, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: uint16, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: int32, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: uint32, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: int64, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(cond: uint64, value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``cond`` is ``True`` then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def where(arr: Array[Any], value_if_true: Any, value_if_false: Any) -> Any:
    """Select between two arguments, if ``arr`` is not null then return ``value_if_true``, otherwise return ``value_if_false``."""
    ...

@over
def atomic_add(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] += value``.
    """
    ...

@over
def atomic_add(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] += value``.
    """
    ...

@over
def atomic_add(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.
    """
    ...

@over
def atomic_add(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.
    """
    ...

@over
def atomic_add(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] += value``.
    """
    ...

@over
def atomic_add(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] += value``.
    """
    ...

@over
def atomic_add(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.
    """
    ...

@over
def atomic_add(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.
    """
    ...

@over
def atomic_add(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] += value``.
    """
    ...

@over
def atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] += value``.
    """
    ...

@over
def atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] += value``.
    """
    ...

@over
def atomic_add(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically adds ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] += value``.
    """
    ...

@over
def atomic_sub(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] -= value``.
    """
    ...

@over
def atomic_sub(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] -= value``.
    """
    ...

@over
def atomic_sub(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.
    """
    ...

@over
def atomic_sub(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.
    """
    ...

@over
def atomic_sub(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] -= value``.
    """
    ...

@over
def atomic_sub(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] -= value``.
    """
    ...

@over
def atomic_sub(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.
    """
    ...

@over
def atomic_sub(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.
    """
    ...

@over
def atomic_sub(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i]`` and returns the original value of ``arr[i]``.

    This function is automatically invoked when using the syntax ``arr[i] -= value``.
    """
    ...

@over
def atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j]`` and returns the original value of ``arr[i,j]``.

    This function is automatically invoked when using the syntax ``arr[i,j] -= value``.
    """
    ...

@over
def atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k]`` and returns the original value of ``arr[i,j,k]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k] -= value``.
    """
    ...

@over
def atomic_sub(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically subtracts ``value`` onto ``arr[i,j,k,l]`` and returns the original value of ``arr[i,j,k,l]``.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] -= value``.
    """
    ...

@over
def atomic_min(arr: Array[Any], i: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_min(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the minimum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: Array[Any], i: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_max(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Compute the maximum of ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: Array[Any], i: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: Array[Any], i: Int, j: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: Array[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: FabricArray[Any], i: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: FabricArray[Any], i: Int, j: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: FabricArray[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: IndexedFabricArray[Any], i: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i]`` if ``arr[i]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j]`` if ``arr[i,j]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k]`` if ``arr[i,j,k]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_cas(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, compare: Any, value: Any) -> Any:
    """Atomically compare and swap ``value`` with ``arr[i,j,k,l]`` if ``arr[i,j,k,l]`` equals ``compare``, and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_exch(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically exchange ``value`` with ``arr[i,j,k,l]`` and return the old value.

    The operation is only atomic on a per-component basis for vectors and matrices.
    """
    ...

@over
def atomic_and(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] &= value``.
    """
    ...

@over
def atomic_and(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] &= value``.
    """
    ...

@over
def atomic_and(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.
    """
    ...

@over
def atomic_and(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.
    """
    ...

@over
def atomic_and(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] &= value``.
    """
    ...

@over
def atomic_and(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] &= value``.
    """
    ...

@over
def atomic_and(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.
    """
    ...

@over
def atomic_and(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.
    """
    ...

@over
def atomic_and(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] &= value``.
    """
    ...

@over
def atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] &= value``.
    """
    ...

@over
def atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] &= value``.
    """
    ...

@over
def atomic_and(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise AND between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] &= value``.
    """
    ...

@over
def atomic_or(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] |= value``.
    """
    ...

@over
def atomic_or(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] |= value``.
    """
    ...

@over
def atomic_or(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.
    """
    ...

@over
def atomic_or(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.
    """
    ...

@over
def atomic_or(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] |= value``.
    """
    ...

@over
def atomic_or(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] |= value``.
    """
    ...

@over
def atomic_or(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.
    """
    ...

@over
def atomic_or(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.
    """
    ...

@over
def atomic_or(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] |= value``.
    """
    ...

@over
def atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] |= value``.
    """
    ...

@over
def atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] |= value``.
    """
    ...

@over
def atomic_or(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise OR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] |= value``.
    """
    ...

@over
def atomic_xor(arr: Array[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] ^= value``.
    """
    ...

@over
def atomic_xor(arr: Array[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.
    """
    ...

@over
def atomic_xor(arr: Array[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.
    """
    ...

@over
def atomic_xor(arr: Array[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.
    """
    ...

@over
def atomic_xor(arr: FabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] ^= value``.
    """
    ...

@over
def atomic_xor(arr: FabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.
    """
    ...

@over
def atomic_xor(arr: FabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.
    """
    ...

@over
def atomic_xor(arr: FabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.
    """
    ...

@over
def atomic_xor(arr: IndexedFabricArray[Any], i: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i] ^= value``.
    """
    ...

@over
def atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j] ^= value``.
    """
    ...

@over
def atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k] ^= value``.
    """
    ...

@over
def atomic_xor(arr: IndexedFabricArray[Any], i: Int, j: Int, k: Int, l: Int, value: Any) -> Any:
    """Atomically performs a bitwise XOR between ``value`` and ``arr[i,j,k,l]``, atomically update the array, and return the old value.

    This function is automatically invoked when using the syntax ``arr[i,j,k,l] ^= value``.
    """
    ...

@over
def lerp(a: Float, b: Float, t: Float) -> Float:
    """Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``."""
    ...

@over
def lerp(a: Vector[Any, Float], b: Vector[Any, Float], t: Float) -> Vector[Any, Float]:
    """Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``."""
    ...

@over
def lerp(a: Matrix[Any, Any, Float], b: Matrix[Any, Any, Float], t: Float) -> Matrix[Any, Any, Float]:
    """Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``."""
    ...

@over
def lerp(a: Quaternion[Float], b: Quaternion[Float], t: Float) -> Quaternion[Float]:
    """Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``."""
    ...

@over
def lerp(a: Transformation[Float], b: Transformation[Float], t: Float) -> Transformation[Float]:
    """Linearly interpolate two values ``a`` and ``b`` using factor ``t``, computed as ``a*(1-t) + b*t``."""
    ...

def smoothstep(a: Float, b: Float, x: Float) -> Float:
    """Smoothly interpolate between two values ``a`` and ``b`` using a factor ``x``,
    and return a result between 0 and 1 using a cubic Hermite interpolation after clamping.
    """
    ...

@over
def expect_near(a: Float, b: Float, tolerance: Float) -> None:
    """Print an error to stdout if ``a`` and ``b`` differ by more than ``tolerance``.

    Compare scalar values.
    """
    ...

@over
def expect_near(a: Vector[Any, Float], b: Vector[Any, Float], tolerance: Float) -> None:
    """Print an error to stdout if ``a`` and ``b`` differ by more than ``tolerance``.

    Compare each vector element.
    """
    ...

@over
def expect_near(a: Quaternion[Float], b: Quaternion[Float], tolerance: Float) -> None:
    """Print an error to stdout if ``a`` and ``b`` differ by more than ``tolerance``.

    Compare each quaternion component.
    """
    ...

@over
def expect_near(a: Matrix[Any, Any, Float], b: Matrix[Any, Any, Float], tolerance: Float) -> None:
    """Print an error to stdout if ``a`` and ``b`` differ by more than ``tolerance``.

    Compare each matrix element.
    """
    ...

@over
def lower_bound(arr: Array[Scalar], value: Scalar) -> int:
    """Search a sorted array ``arr`` for the closest element greater than or equal to ``value``."""
    ...

@over
def lower_bound(arr: Array[Scalar], arr_begin: int32, arr_end: int32, value: Scalar) -> int:
    """Search a sorted array ``arr`` for the closest element greater than or equal to ``value``.

    Search the range [arr_begin, arr_end).
    """
    ...

@over
def add(a: Scalar, b: Scalar) -> Scalar:
    """Add ``a`` and ``b``."""
    ...

@over
def add(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Add ``a`` and ``b``."""
    ...

@over
def add(a: Quaternion[Float], b: Quaternion[Float]) -> Quaternion[Float]:
    """Add ``a`` and ``b``."""
    ...

@over
def add(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Add ``a`` and ``b``."""
    ...

@over
def add(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]:
    """Add ``a`` and ``b``."""
    ...

@over
def add(a: Tile[Any, tuple[int, ...]], b: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Add ``a`` and ``b``."""
    ...

@over
def sub(a: Scalar, b: Scalar) -> Scalar:
    """Subtract ``b`` from ``a``."""
    ...

@over
def sub(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Subtract ``b`` from ``a``."""
    ...

@over
def sub(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Subtract ``b`` from ``a``."""
    ...

@over
def sub(a: Quaternion[Float], b: Quaternion[Float]) -> Quaternion[Float]:
    """Subtract ``b`` from ``a``."""
    ...

@over
def sub(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]:
    """Subtract ``b`` from ``a``."""
    ...

@over
def sub(a: Tile[Any, tuple[int, ...]], b: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Subtract ``b`` from ``a``."""
    ...

@over
def bit_and(a: Int, b: Int) -> Int:
    """Compute the bitwise AND of ``a`` and ``b``."""
    ...

@over
def bit_and(a: Vector[Any, Int], b: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute the bitwise AND of ``a`` and ``b``.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def bit_and(a: Matrix[Any, Any, Int], b: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute the bitwise AND of ``a`` and ``b``.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def bit_and(a: Tile[Any, tuple[int, ...]], b: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Compute the bitwise AND of ``a`` and ``b``.

    Apply the operation element-wise to tiles.
    """
    ...

@over
def bit_or(a: Int, b: Int) -> Int:
    """Compute the bitwise OR of ``a`` and ``b``."""
    ...

@over
def bit_or(a: Vector[Any, Int], b: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute the bitwise OR of ``a`` and ``b``.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def bit_or(a: Matrix[Any, Any, Int], b: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute the bitwise OR of ``a`` and ``b``.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def bit_or(a: Tile[Any, tuple[int, ...]], b: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Compute the bitwise OR of ``a`` and ``b``.

    Apply the operation element-wise to tiles.
    """
    ...

@over
def bit_xor(a: Int, b: Int) -> Int:
    """Compute the bitwise XOR of ``a`` and ``b``."""
    ...

@over
def bit_xor(a: Vector[Any, Int], b: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute the bitwise XOR of ``a`` and ``b``.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def bit_xor(a: Matrix[Any, Any, Int], b: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute the bitwise XOR of ``a`` and ``b``.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def bit_xor(a: Tile[Any, tuple[int, ...]], b: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Compute the bitwise XOR of ``a`` and ``b``.

    Apply the operation element-wise to tiles.
    """
    ...

@over
def lshift(a: Int, b: Int) -> Int:
    """Compute ``a`` left-shifted by ``b`` bits."""
    ...

@over
def lshift(a: Vector[Any, Int], b: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute ``a`` left-shifted by ``b`` bits.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def lshift(a: Matrix[Any, Any, Int], b: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute ``a`` left-shifted by ``b`` bits.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def rshift(a: Int, b: Int) -> Int:
    """Compute ``a`` right-shifted by ``b`` bits."""
    ...

@over
def rshift(a: Vector[Any, Int], b: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute ``a`` right-shifted by ``b`` bits.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def rshift(a: Matrix[Any, Any, Int], b: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute ``a`` right-shifted by ``b`` bits.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def invert(a: Int) -> Int:
    """Compute the bitwise complement of ``a``."""
    ...

@over
def invert(a: Vector[Any, Int]) -> Vector[Any, Int]:
    """Compute the bitwise complement of ``a``.

    Apply the operation element-wise to vectors.
    """
    ...

@over
def invert(a: Matrix[Any, Any, Int]) -> Matrix[Any, Any, Int]:
    """Compute the bitwise complement of ``a``.

    Apply the operation element-wise to matrices.
    """
    ...

@over
def mul(a: Scalar, b: Scalar) -> Scalar:
    """Multiply two values."""
    ...

@over
def mul(a: Vector[Any, Scalar], b: Scalar) -> Vector[Any, Scalar]:
    """Multiply two values.

    Scale a vector by a scalar.
    """
    ...

@over
def mul(a: Scalar, b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Multiply two values.

    Scale a vector by a scalar.
    """
    ...

@over
def mul(a: Quaternion[Float], b: Scalar) -> Quaternion[Float]:
    """Multiply two values.

    Scale a quaternion by a scalar.
    """
    ...

@over
def mul(a: Scalar, b: Quaternion[Float]) -> Quaternion[Float]:
    """Multiply two values.

    Scale a quaternion by a scalar.
    """
    ...

@over
def mul(a: Quaternion[Float], b: Quaternion[Float]) -> Quaternion[Float]:
    """Multiply two values.

    Compute the Hamilton product of two quaternions.
    """
    ...

@over
def mul(a: Scalar, b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Multiply two values.

    Scale a matrix by a scalar.
    """
    ...

@over
def mul(a: Matrix[Any, Any, Scalar], b: Scalar) -> Matrix[Any, Any, Scalar]:
    """Multiply two values.

    Scale a matrix by a scalar.
    """
    ...

@over
def mul(a: Matrix[Any, Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Multiply two values.

    Compute a matrix-vector product.
    """
    ...

@over
def mul(a: Vector[Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Vector[Any, Scalar]:
    """Multiply two values.

    Compute a row-vector-by-matrix product.
    """
    ...

@over
def mul(a: Matrix[Any, Any, Scalar], b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Multiply two values.

    Compute a matrix-matrix product.
    """
    ...

@over
def mul(a: Transformation[Float], b: Transformation[Float]) -> Transformation[Float]:
    """Multiply two values.

    Compose transformations (apply ``b`` then ``a``).
    """
    ...

@over
def mul(a: Scalar, b: Transformation[Float]) -> Transformation[Float]:
    """Multiply two values.

    Scale a transformation by a scalar.

    The result has an unnormalized quaternion.
    """
    ...

@over
def mul(a: Transformation[Float], b: Scalar) -> Transformation[Float]:
    """Multiply two values.

    Scale a transformation by a scalar.

    The result has an unnormalized quaternion.
    """
    ...

@over
def mul(x: Tile[Any, tuple[int, ...]], y: Any) -> Tile[Any, tuple[int, ...]]:
    """Multiply two values.

    Scale each element of a tile by a scalar.

    If the tile's element type is not scalar, the constant must be a scalar type and vice versa.
    Underlying scalar types must match. Result dtype follows standard scalar multiplication rules.
    """
    ...

@over
def mul(x: Any, y: Tile[Any, tuple[int, ...]]) -> Tile[Any, tuple[int, ...]]:
    """Multiply two values.

    Scale each element of a tile by a scalar.

    If the tile's element type is not scalar, the constant must be a scalar type and vice versa.
    Underlying scalar types must match. Result dtype follows standard scalar multiplication rules.
    """
    ...

@over
def mod(a: Scalar, b: Scalar) -> Scalar:
    """Modulo operation using truncated division."""
    ...

@over
def mod(a: Vector[Any, Scalar], b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Modulo operation using truncated division."""
    ...

@over
def div(a: Scalar, b: Scalar) -> Scalar:
    """Divide two values."""
    ...

@over
def div(a: Vector[Any, Scalar], b: Scalar) -> Vector[Any, Scalar]:
    """Divide two values.

    Divide a vector by a scalar.
    """
    ...

@over
def div(a: Scalar, b: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Divide two values.

    Divide a scalar by each element of a vector.
    """
    ...

@over
def div(a: Matrix[Any, Any, Scalar], b: Scalar) -> Matrix[Any, Any, Scalar]:
    """Divide two values.

    Divide a matrix by a scalar.
    """
    ...

@over
def div(a: Scalar, b: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Divide two values.

    Divide a scalar by each element of a matrix.
    """
    ...

@over
def div(a: Quaternion[Float], b: Scalar) -> Quaternion[Float]:
    """Divide two values.

    Divide a quaternion by a scalar.

    The result is unnormalized.
    """
    ...

@over
def div(a: Scalar, b: Quaternion[Float]) -> Quaternion[Float]:
    """Divide two values.

    Divide a scalar by a quaternion.

    The result is unnormalized.
    """
    ...

def floordiv(a: Scalar, b: Scalar) -> Scalar:
    """Divide two scalars using floor division."""
    ...

@over
def pos(x: Scalar) -> Scalar:
    """Pass ``x`` unchanged."""
    ...

@over
def pos(x: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Pass ``x`` unchanged."""
    ...

@over
def pos(x: Quaternion[Float]) -> Quaternion[Float]:
    """Pass ``x`` unchanged."""
    ...

@over
def pos(x: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Pass ``x`` unchanged."""
    ...

@over
def neg(x: Scalar) -> Scalar:
    """Negate ``x``."""
    ...

@over
def neg(x: Vector[Any, Scalar]) -> Vector[Any, Scalar]:
    """Negate ``x``."""
    ...

@over
def neg(x: Quaternion[Float]) -> Quaternion[Float]:
    """Negate ``x``."""
    ...

@over
def neg(x: Matrix[Any, Any, Scalar]) -> Matrix[Any, Any, Scalar]:
    """Negate ``x``."""
    ...

@over
def neg(x: Tile[Any, tuple[int, ...]]) -> Tile[Scalar, tuple[int, ...]]:
    """Negate ``x``.

    Negate tiles element-wise.
    """
    ...

@over
def unot(a: bool) -> bool:
    """Compute logical NOT of ``a``."""
    ...

@over
def unot(a: int8) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: uint8) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: int16) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: uint16) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: int32) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: uint32) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: int64) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: uint64) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the integer is 0, ``False`` otherwise.
    """
    ...

@over
def unot(a: Array[Any]) -> bool:
    """Compute logical NOT of ``a``.

    Returns:
        ``True`` if the array is empty or null, ``False`` otherwise.
    """
    ...

def tile_diag_add(a: Tile[Any, tuple[int, int]], d: Tile[Any, tuple[int]]) -> Tile[Any, tuple[int, int]]:
    """Add a square matrix and a diagonal matrix ``d`` represented as a 1D tile."""
    ...

@over
def tile_matmul(
    a: Tile[Float, tuple[int, int]],
    b: Tile[Float, tuple[int, int]],
    out: Tile[Float, tuple[int, int]],
    alpha: Float,
    beta: Float,
) -> None:
    """Compute the matrix product ``a*b``.

    Compute ``out = alpha * a*b + beta * out``.

    Supported datatypes are:
        * fp16, fp32, fp64 (real)
        * vec2h, vec2f, vec2d (complex)

    All input and output tiles must have the same datatype. Tile data will automatically be migrated
    to shared memory if necessary and will use TensorCore operations when available.

    Note that computing the adjoints of alpha and beta are not yet supported.

    Args:
        a: A tile with ``shape=(M, K)``
        b: A tile with ``shape=(K, N)``
        out: A tile with ``shape=(M, N)``
        alpha: Scaling factor (default 1.0)
        beta: Accumulator factor (default 1.0)

    """
    ...

@over
def tile_matmul(
    a: Tile[Float, tuple[int, int]], b: Tile[Float, tuple[int, int]], alpha: Float
) -> Tile[Float, tuple[int, int]]:
    """Compute the matrix product ``a*b``.

    Compute ``out = alpha * a*b``.

    Supported datatypes are:
        * fp16, fp32, fp64 (real)
        * vec2h, vec2f, vec2d (complex)

    Both input tiles must have the same datatype. Tile data will automatically be migrated
    to shared memory if necessary and will use TensorCore operations when available.

    Note that computing the adjoints of alpha is not yet supported.

    Args:
        a: A tile with ``shape=(M, K)``
        b: A tile with ``shape=(K, N)``
        alpha: Scaling factor (default 1.0)

    Returns:
        A tile with ``shape=(M, N)``

    """
    ...

def tile_fft(inout: Tile[Vector[Literal[2], Float], tuple[int, int]]) -> None:
    """Compute the forward FFT along the second dimension of a 2D tile of data.

    This function cooperatively computes the forward FFT on a tile of data inplace, treating each row individually.

    The transform is unnormalized, meaning that applying :func:`tile_fft` followed by :func:`tile_ifft`
    will scale the data by N, where N is the FFT size (the second dimension of the tile).
    Normalization is left to the user to perform as needed.

    Supported datatypes are:
        * vec2f, vec2d

    Args:
        inout: The input/output tile.
    """
    ...

def tile_ifft(inout: Tile[Vector[Literal[2], Float], tuple[int, int]]) -> None:
    """Compute the inverse FFT along the second dimension of a 2D tile of data.

    This function cooperatively computes the inverse FFT on a tile of data inplace, treating each row individually.

    The transform is unnormalized, meaning that applying :func:`tile_fft` followed by :func:`tile_ifft`
    will scale the data by N, where N is the FFT size (the second dimension of the tile).
    Normalization is left to the user to perform as needed.

    Supported datatypes are:
        * vec2f, vec2d

    Args:
        inout: The input/output tile.
    """
    ...

def tile_cholesky(A: Tile[Float, tuple[int, int]]) -> Tile[Float, tuple[int, int]]:
    """Compute the Cholesky factorization ``L`` of a matrix ``A``.

    ``L`` is lower triangular and satisfies ``LL^T = A``.

    Only the lower triangular portion of ``A`` is used for the decomposition;
    the upper triangular part may be left unspecified.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    Args:
        A: A square, symmetric positive-definite, matrix. Only the lower triangular part of ``A`` is needed; the upper part is ignored.

    Returns:
        A square, lower triangular matrix, such that ``LL^T = A``.
    """
    ...

def tile_cholesky_inplace(A: Tile[Float, tuple[int, int]]) -> None:
    """Compute the Cholesky factorization ``L`` of a matrix ``A``.

    ``L`` is lower triangular and satisfies ``LL^T = A``.

    Only the lower triangular portion of ``A`` is used for the decomposition;
    the upper triangular part may be left unspecified.

    Note: This inplace variant does not support automatic differentiation (adjoint computation),
    but offers improved performance and uses half the shared memory compared to the standard version.

    Supported datatypes are:
        * float32
        * float64

    Args:
        A: A square, symmetric positive-definite, matrix. Only the lower triangular part of ``A`` is replaced by ``L``, such that ``LL^T = A``; the upper part is untouched.
    """
    ...

def tile_cholesky_solve(L: Tile[Float, tuple[int, int]], y: Tile[Float, tuple[int]]) -> Tile[Float, tuple[int]]:
    """Solve for ``x`` in ``Ax = y``.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    Args:
        L: A square, lower triangular, matrix, such that ``LL^T = A``.
        y: A 1D or 2D tile of length ``M``.

    Returns:
        A tile of the same shape as ``y`` such that ``LL^T x = y``.
    """
    ...

def tile_cholesky_solve_inplace(L: Tile[Float, tuple[int, int]], y: Tile[Float, tuple[int]]) -> None:
    """Solve for ``x`` in ``Ax = y`` by overwriting ``y`` with ``x``.

    Note: This inplace variant does not support automatic differentiation (adjoint computation),
    but avoids allocating shared memory for the output ``x`` by reusing ``y``'s memory.

    Supported datatypes are:
        * float32
        * float64

    Args:
        L: A square, lower triangular, matrix, such that ``LL^T = A``.
        y: A 1D or 2D tile of length ``M`` that gets overwritten by ``x`` where ``LL^T x = y``.
    """
    ...

def tile_lower_solve(L: Tile[Float, tuple[int, int]], y: Tile[Float, tuple[int]]) -> Tile[Float, tuple[int]]:
    """Solve for ``z`` in ``Lz = y``, where ``L`` is a lower triangular matrix.

    This performs general forward substitution for a lower triangular system.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    Args:
        L: A square, non-singular, lower triangular matrix
        y: A 1D or 2D tile with compatible shape

    Returns:
        A tile of the same shape as ``y`` such that ``Lz = y``.
    """
    ...

def tile_lower_solve_inplace(L: Tile[Float, tuple[int, int]], y: Tile[Float, tuple[int]]) -> None:
    """Solve for ``z`` in ``Lz = y``, where ``L`` is a lower triangular matrix by overwriting ``y`` with ``z``.

    This performs general forward substitution for a lower triangular system inplace.

    Note: This inplace variant does not support automatic differentiation (adjoint computation),
    but avoids allocating shared memory for the output ``z`` by reusing ``y``'s memory.

    Supported datatypes are:
        * float32
        * float64

    Args:
        L: A square, non-singular, lower triangular matrix
        y: A 1D or 2D tile with compatible shape that gets overwritten by ``z`` where ``Lz = y``.
    """
    ...

def tile_upper_solve(U: Tile[Float, tuple[int, int]], z: Tile[Float, tuple[int]]) -> Tile[Float, tuple[int]]:
    """Solve for ``x`` in ``Ux = z``, where ``U`` is an upper triangular matrix.

    This performs general back substitution for upper triangular systems.

    Note that computing the adjoint is not yet supported.

    Supported datatypes are:
        * float32
        * float64

    Args:
        U: A square, non-singular, upper triangular matrix
        z: A 1D or 2D tile with compatible shape

    Returns:
        A tile of the same shape as ``z`` such that ``Ux = z``.
    """
    ...

def tile_upper_solve_inplace(U: Tile[Float, tuple[int, int]], z: Tile[Float, tuple[int]]) -> None:
    """Solve for ``x`` in ``Ux = z``, where ``U`` is an upper triangular matrix by overwriting ``z`` with ``x``.

    This performs general back substitution for upper triangular systems inplace.

    Note: This inplace variant does not support automatic differentiation (adjoint computation),
    but avoids allocating shared memory for the output ``x`` by reusing ``z``'s memory.

    Supported datatypes are:
        * float32
        * float64

    Args:
        U: A square, non-singular, upper triangular matrix
        z: A 1D or 2D tile with compatible shape that gets overwritten by ``x`` where ``Ux = z``.
    """
    ...

@over
def len(a: Vector[Any, Scalar]) -> int:
    """Query the number of elements in a vector."""
    ...

@over
def len(a: Quaternion[Float]) -> int:
    """Query the number of elements in a quaternion."""
    ...

@over
def len(a: Matrix[Any, Any, Scalar]) -> int:
    """Query the number of rows in a matrix."""
    ...

@over
def len(a: Transformation[Float]) -> int:
    """Query the number of elements in a transformation."""
    ...

@over
def len(a: Array[Any]) -> int:
    """Query the size of the first dimension in an array."""
    ...

@over
def len(a: Tile[Any, tuple[int, ...]]) -> int:
    """Query the number of rows in a tile."""
    ...

@over
def len(a: tuple) -> int:
    """Query the number of elements in a tuple."""
    ...

def cast(a: Any, dtype: Any) -> Any:
    """Reinterpret a value as a different type while preserving its bit pattern.

    Args:
        a: The value to cast
        dtype: The target type.

    Example:

        .. code-block:: python

            @wp.struct
            class MyStruct:
                f: wp.float16
                i: wp.int16

            @wp.kernel
            def compute():
                x = wp.int32(0x40000000)
                x_casted = wp.cast(x, wp.float32)
                wp.expect_eq(x_casted, 2.0)  # 0x40000000

                s = MyStruct()
                s.f = wp.float16(2.0)  # 0x4000
                s.i = wp.int16(4096)  # 0x1000
                s_casted = wp.cast(s, wp.int32)
                wp.expect_eq(s_casted, 0x10004000)

            wp.launch(compute, dim=1)

    """
    ...
